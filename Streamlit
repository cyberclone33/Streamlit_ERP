import streamlit as st
import pandas as pd
import numpy as np
import os
import shutil
from io import BytesIO
from datetime import datetime

# Configure page and set up data directories
st.set_page_config(page_title="FAFA ERP æ™ºèƒ½éŠ·å”®åŠ©ç†", layout="wide")

# Initialize session state for section navigation if it doesn't exist
if 'current_section' not in st.session_state:
    st.session_state.current_section = "ç”Ÿæˆå ±è¡¨"

# Define the main sections of the app
sections = ["ç”Ÿæˆå ±è¡¨", "è¨‚å–®èª¿é–±", "ç”¢å“åˆ†æ", "BC è³‡æ–™æ¯”å°", "å» å•†ç”¢å“æŸ¥è©¢"]

# Horizontal navigation bar
col1, col2, col3, col4, col5 = st.columns(5)
with col1:
    if st.button("è¨‚å–®èª¿é–±", use_container_width=True):
        st.session_state.current_section = "è¨‚å–®èª¿é–±"
with col2:
    if st.button("ç”¢å“åˆ†æ", use_container_width=True):
        st.session_state.current_section = "ç”¢å“åˆ†æ"
with col3:
    if st.button("BC è³‡æ–™æ¯”å°", use_container_width=True):
        st.session_state.current_section = "BC è³‡æ–™æ¯”å°"
with col4:
    if st.button("å» å•†ç”¢å“æŸ¥è©¢", use_container_width=True):
        st.session_state.current_section = "å» å•†ç”¢å“æŸ¥è©¢"
with col5:
    if st.button("ç”Ÿæˆå ±è¡¨", use_container_width=True):
        st.session_state.current_section = "ç”Ÿæˆå ±è¡¨"

st.title(f"ğŸ“Š FAFA - ERP æ™ºèƒ½éŠ·å”®åŠ©ç† - {st.session_state.current_section}")

# Create data storage directories if they don't exist
DATA_DIR = "uploaded_data"
SALES_DIR = os.path.join(DATA_DIR, "sales_files")
BC_DIR = os.path.join(DATA_DIR, "bc_files")

os.makedirs(SALES_DIR, exist_ok=True)
os.makedirs(BC_DIR, exist_ok=True)

# =================== UTILITY FUNCTIONS ===================

def save_uploaded_file(uploaded_file, directory):
    """Save an uploaded file to the specified directory and return the file path
    If a file with the same name already exists, it will be overwritten"""
    filename = uploaded_file.name
    # Use the original filename without timestamp to avoid duplicates
    file_path = os.path.join(directory, filename)
    
    # Save the file, overwriting if it already exists
    with open(file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    
    return file_path

def get_file_list(directory, file_type=None):
    """Get list of files from the specified directory"""
    if not os.path.exists(directory):
        return []
    
    files = []
    for filename in os.listdir(directory):
        if file_type and not filename.endswith(file_type):
            continue
        file_path = os.path.join(directory, filename)
        if os.path.isfile(file_path):
            # Get file modification time for sorting
            mod_time = os.path.getmtime(file_path)
            # Store filename and path (original name is now the same as filename)
            files.append({
                "name": filename, 
                "path": file_path, 
                "full_name": filename,
                "mod_time": mod_time,
                "mod_time_str": datetime.fromtimestamp(mod_time).strftime("%Y/%m/%d %H:%M")
            })
    
    # Sort by modification time (newest first)
    files.sort(key=lambda x: x["mod_time"], reverse=True)
    return files

def delete_file(file_path):
    """Delete a file from the filesystem"""
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
            return True
        return False
    except Exception as e:
        st.error(f"åˆªé™¤æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        return False

def load_saved_excel_file(file_path):
    """Load a saved Excel file from disk"""
    return pd.read_excel(file_path)

def clean_numeric_columns(df, columns):
    for col in columns:
        df[col] = df[col].astype(str).str.replace(',', '', regex=False)
        df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0).round(0).astype(int)
    return df

def load_sales_data(files, selected_months, is_path=False, column_mapping=None):
    df_list = []
    
    for file in files:
        # Handle both file objects and file paths
        if is_path:
            file_name = os.path.basename(file)
            file_path = file
        else:
            file_name = file.name
            file_path = file
            
        for month in selected_months:
            if month in file_name:
                try:
                    if is_path:
                        df = pd.read_excel(file_path)
                    else:
                        df = pd.read_excel(file_path)
                    
                    # Apply column mapping if provided
                    if column_mapping and isinstance(column_mapping, dict):
                        # Rename columns according to the mapping
                        df = df.rename(columns=column_mapping)
                    
                    # Process the hierarchical structure before adding to list
                    # This preserves order information by filling NaN values in order columns
                    # with the values from the first row of each order
                    order_columns = ['éŠ·è²¨å–®è™Ÿ', 'è¨‚å–®å–®è™Ÿ', 'éŠ·è²¨æ—¥æœŸ', 'å®¢æˆ¶ä»£è™Ÿ', 'å®¢æˆ¶åç¨±', 
                                    'éƒ¨é–€ä»£è™Ÿ', 'éƒ¨é–€åç¨±', 'ç™¼ç¥¨è™Ÿç¢¼', 'æœªç¨…å°è¨ˆ', 'ç‡Ÿæ¥­ç¨…', 
                                    'æŠ˜è®“é‡‘é¡', 'ç¨…å‰æŠ˜åƒ¹', 'ç¸½è¨ˆé‡‘é¡', 'å¯¦æ”¶ç¸½é¡', 'æˆæœ¬ç¸½é¡', 'æ¯›åˆ©', 'æ¯›åˆ©ç‡']
                    
                    # First check if all required order columns exist
                    missing_cols = [col for col in order_columns if col not in df.columns]
                    for col in missing_cols:
                        df[col] = None  # Add missing columns with None values
                    
                    # Forward fill the order information
                    df[order_columns] = df[order_columns].fillna(method='ffill')
                    
                    # Add order identification column
                    if 'éŠ·è²¨å–®è™Ÿ' in df.columns:
                        df['order_id'] = df['éŠ·è²¨å–®è™Ÿ'].astype(str)
                    
                    df_list.append(df)
                except Exception as e:
                    st.error(f"ç„¡æ³•è®€å–æª”æ¡ˆ {file_name}: {e}")
                break
                
    if df_list:
        combined = pd.concat(df_list, ignore_index=True)
        
        # Process numeric columns
        numeric_cols = ['æ•¸é‡', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©']
        for col in numeric_cols:
            if col not in combined.columns:
                combined[col] = 0
        combined = clean_numeric_columns(combined, numeric_cols)
        
        # Also ensure numeric processing for order-level columns
        order_numeric_cols = ['æœªç¨…å°è¨ˆ', 'ç‡Ÿæ¥­ç¨…', 'æŠ˜è®“é‡‘é¡', 'ç¨…å‰æŠ˜åƒ¹', 
                             'ç¸½è¨ˆé‡‘é¡', 'å¯¦æ”¶ç¸½é¡', 'æˆæœ¬ç¸½é¡', 'æ¯›åˆ©']
        existing_order_numeric_cols = [col for col in order_numeric_cols if col in combined.columns]
        if existing_order_numeric_cols:
            combined = clean_numeric_columns(combined, existing_order_numeric_cols)
        
        return combined
    return pd.DataFrame()

def generate_monthly_summary(df):
    grouped = df.groupby('ç”¢å“ä»£è™Ÿ').agg({
        'æ•¸é‡': 'sum',
        'å°è¨ˆ': 'sum',
        'ç²¾æº–æˆæœ¬': 'sum',
        'ç²¾æº–æ¯›åˆ©': 'sum',
        'ç”¢å“åç¨±': 'first',
        'å€‰åˆ¥ä»£è™Ÿ': 'first',
        'å€‰åˆ¥åç¨±': 'first'
    }).reset_index()
    return grouped.sort_values(by='å°è¨ˆ', ascending=False)

def generate_order_summary(df):
    """Generate a summary table at the order level"""
    # Check if we have the necessary order columns
    required_cols = ['éŠ·è²¨å–®è™Ÿ', 'éŠ·è²¨æ—¥æœŸ', 'å®¢æˆ¶åç¨±']
    if not all(col in df.columns for col in required_cols):
        return pd.DataFrame()  # Return empty DataFrame if missing required columns
    
    # Get unique order rows (first row of each order)
    # The order information should already be on the first row of each order group
    order_df = df.drop_duplicates(subset=['éŠ·è²¨å–®è™Ÿ']).copy()
    
    # Select only order-level columns
    order_cols = ['éŠ·è²¨å–®è™Ÿ', 'è¨‚å–®å–®è™Ÿ', 'éŠ·è²¨æ—¥æœŸ', 'å®¢æˆ¶ä»£è™Ÿ', 'å®¢æˆ¶åç¨±', 
                'éƒ¨é–€ä»£è™Ÿ', 'éƒ¨é–€åç¨±', 'ç™¼ç¥¨è™Ÿç¢¼', 'æœªç¨…å°è¨ˆ', 'ç‡Ÿæ¥­ç¨…', 
                'æŠ˜è®“é‡‘é¡', 'ç¨…å‰æŠ˜åƒ¹', 'ç¸½è¨ˆé‡‘é¡', 'å¯¦æ”¶ç¸½é¡', 'æˆæœ¬ç¸½é¡', 'æ¯›åˆ©', 'æ¯›åˆ©ç‡']
    
    # Filter to only include columns that exist in the DataFrame
    existing_cols = [col for col in order_cols if col in order_df.columns]
    
    if not existing_cols:
        return pd.DataFrame()  # Return empty DataFrame if no order columns exist
    
    # Start with just the order-level columns
    order_summary = order_df[existing_cols].copy()
    
    # Add product count for each order
    product_counts = df.groupby('éŠ·è²¨å–®è™Ÿ').size().reset_index(name='ç”¢å“æ•¸é‡')
    order_summary = pd.merge(order_summary, product_counts, on='éŠ·è²¨å–®è™Ÿ', how='left')
    
    # DO NOT recalculate totals - use the existing order-level totals
    # Only if 'ç¸½è¨ˆé‡‘é¡' is not already present, calculate a total from product subtotals
    if 'ç¸½è¨ˆé‡‘é¡' not in order_summary.columns and 'å°è¨ˆ' in df.columns:
        # Sum up product subtotals for each order
        product_totals = df.groupby('éŠ·è²¨å–®è™Ÿ')['å°è¨ˆ'].sum().reset_index(name='è¨‚å–®ç”¢å“ç¸½é¡')
        order_summary = pd.merge(order_summary, product_totals, on='éŠ·è²¨å–®è™Ÿ', how='left')
    
    # Sort by date (newest first) and then by order number
    if 'éŠ·è²¨æ—¥æœŸ' in order_summary.columns:
        order_summary = order_summary.sort_values(by=['éŠ·è²¨æ—¥æœŸ', 'éŠ·è²¨å–®è™Ÿ'], ascending=[False, True])
    
    return order_summary

def generate_customer_summary(df):
    """Generate a summary of top customers"""
    # Check if we have the necessary customer columns
    if 'customer_summary' in st.session_state:
        return st.session_state.customer_summary
        
    required_cols = ['å®¢æˆ¶åç¨±', 'ç¸½è¨ˆé‡‘é¡']
    
    # Determine which amount column to use
    amount_col = None
    for col in ['ç¸½è¨ˆé‡‘é¡', 'å¯¦æ”¶ç¸½é¡', 'æœªç¨…å°è¨ˆ', 'è¨‚å–®ç”¢å“ç¸½é¡']:
        if col in df.columns:
            amount_col = col
            break
    
    if 'å®¢æˆ¶åç¨±' not in df.columns or amount_col is None:
        return pd.DataFrame()  # Return empty DataFrame if missing required columns
    
    # Group by customer name and sum the total amount
    customer_summary = df.groupby('å®¢æˆ¶åç¨±').agg({
        amount_col: 'sum',
        'éŠ·è²¨å–®è™Ÿ': 'nunique'  # Count unique order numbers
    }).reset_index()
    
    # Rename columns for clarity
    customer_summary.rename(columns={
        amount_col: 'æ¶ˆè²»ç¸½é¡',
        'éŠ·è²¨å–®è™Ÿ': 'è¨‚å–®æ•¸é‡'
    }, inplace=True)
    
    # Calculate average order value
    customer_summary['å¹³å‡å–®ç­†é‡‘é¡'] = customer_summary['æ¶ˆè²»ç¸½é¡'] / customer_summary['è¨‚å–®æ•¸é‡']
    
    # Sort by total amount spent, descending
    customer_summary = customer_summary.sort_values(by='æ¶ˆè²»ç¸½é¡', ascending=False)
    
    # Save to session state to avoid recomputation
    st.session_state.customer_summary = customer_summary
    
    return customer_summary

def merge_with_bc(sales_df, bc_df):
    merged = pd.merge(bc_df, sales_df, on='ç”¢å“ä»£è™Ÿ', how='left')
    fill_cols = ['æ•¸é‡_y', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©']
    for col in fill_cols:
        if col in merged.columns:
            merged[col] = merged[col].fillna(0).astype(int)
    merged.rename(columns={
        'æ•¸é‡_x': 'åº«å­˜æ•¸é‡',
        'æ•¸é‡_y': 'éŠ·å”®æ•¸é‡'
    }, inplace=True)
    return merged

def vendor_summary_table(df):
    summary = df.groupby('å» å•†ç°¡ç¨±').agg({
        'å°è¨ˆ': 'sum'
    }).reset_index().rename(columns={'å°è¨ˆ': 'å» å•†ç¸½å°è¨ˆ'}).sort_values(by='å» å•†ç¸½å°è¨ˆ', ascending=False)
    return summary

def extract_months_from_filenames(files):
    months = []
    for f in files:
        name = f.name
        try:
            # Try to extract a date pattern from the filename
            # Look for common patterns like 202403, 2024-03, 2024_03, etc.
            import re
            
            # First try to find year-month patterns like 202401, 2024-01, etc.
            date_patterns = [
                r'(\d{6})',  # Simple 6-digit pattern like 202401
                r'(\d{4}[-_][01]\d)',  # Patterns like 2024-01 or 2024_01
                r'(\d{4}å¹´[01]?\dæœˆ)'  # Chinese format like 2024å¹´1æœˆ
            ]
            
            found_date = False
            for pattern in date_patterns:
                matches = re.findall(pattern, name)
                if matches:
                    for match in matches:
                        # Clean up the match to get a standard YYYYMM format
                        clean_match = re.sub(r'[-_å¹´æœˆ]', '', match)
                        # Only accept if it starts with a valid year (20xx)
                        if clean_match.startswith('20') and len(clean_match) >= 6:
                            year_month = clean_match[:6]  # Take first 6 digits as YYYYMM
                            months.append(year_month)
                            found_date = True
                            break
                if found_date:
                    break
            
            # If no date pattern found and filename contains numbers, use first 6 digits as fallback
            if not found_date:
                digits = ''.join(c for c in name if c.isdigit())
                if len(digits) >= 6:
                    year_month = digits[:6]
                    # Only accept if it starts with a valid year (20xx)
                    if year_month.startswith('20'):
                        months.append(year_month)
        except:
            continue
    
    return sorted(list(set(months)), reverse=True)

def check_required_columns(df, required_columns):
    """
    Check if all required columns exist in the DataFrame and suggest column mappings for missing ones
    Returns:
    - present_columns: list of required columns that are present
    - missing_columns: list of required columns that are missing
    - suggestions: dict mapping missing columns to potential matches in df
    """
    present_columns = []
    missing_columns = []
    suggestions = {}
    
    df_columns = set(df.columns)
    
    for col in required_columns:
        if col in df_columns:
            present_columns.append(col)
        else:
            missing_columns.append(col)
            
            # Suggest similar column names
            potential_matches = []
            for df_col in df.columns:
                # Check if the required column's characters are mostly contained in any existing column
                # This helps with slightly different naming conventions
                if len(set(col) & set(df_col)) / len(col) > 0.7:
                    potential_matches.append(df_col)
            
            if potential_matches:
                suggestions[col] = potential_matches
    
    return present_columns, missing_columns, suggestions

# =================== MAIN PAGE ===================

# Define required headers for later use
required_headers = [
    "å®¢æˆ¶ä»£è™Ÿ", "å®¢æˆ¶åç¨±", "éƒ¨é–€ä»£è™Ÿ", "éƒ¨é–€åç¨±", "ç™¼ç¥¨è™Ÿç¢¼", "æœªç¨…å°è¨ˆ", "ç‡Ÿæ¥­ç¨…",
    "æŠ˜è®“é‡‘é¡", "ç¨…å‰æŠ˜åƒ¹", "ç¸½è¨ˆé‡‘é¡", "å¯¦æ”¶ç¸½é¡", "æˆæœ¬ç¸½é¡", "æ¯›åˆ©", "æ¯›åˆ©ç‡",
    "ç”¢å“ä»£è™Ÿ", "ç”¢å“åç¨±", "å€‰åˆ¥ä»£è™Ÿ", "å€‰åˆ¥åç¨±", "æ•¸é‡", "å–®ä½", "å–®åƒ¹", "å°è¨ˆ",
    "æˆæœ¬ç¸½å€¼", "ç”¢å“æ¯›åˆ©", "ç”¢å“æ¯›åˆ©ç‡", "éŠ·å”®å–®åƒ¹1", "ç²¾æº–æˆæœ¬", "ç²¾æº–æ¯›åˆ©",
    "å–®ä½ç®¡éŠ·æˆæœ¬", "ç®¡éŠ·æˆæœ¬åˆè¨ˆ"
]

# Group headers by category for better organization
header_categories = {
    "è¨‚å–®åŸºæœ¬è³‡è¨Š": ["éŠ·è²¨å–®è™Ÿ", "è¨‚å–®å–®è™Ÿ", "éŠ·è²¨æ—¥æœŸ"],
    "å®¢æˆ¶è³‡è¨Š": ["å®¢æˆ¶ä»£è™Ÿ", "å®¢æˆ¶åç¨±", "éƒ¨é–€ä»£è™Ÿ", "éƒ¨é–€åç¨±", "ç™¼ç¥¨è™Ÿç¢¼"],
    "è¨‚å–®é‡‘é¡è³‡è¨Š": ["æœªç¨…å°è¨ˆ", "ç‡Ÿæ¥­ç¨…", "æŠ˜è®“é‡‘é¡", "ç¨…å‰æŠ˜åƒ¹", "ç¸½è¨ˆé‡‘é¡", "å¯¦æ”¶ç¸½é¡", "æˆæœ¬ç¸½é¡", "æ¯›åˆ©", "æ¯›åˆ©ç‡"],
    "ç”¢å“è³‡è¨Š": ["ç”¢å“ä»£è™Ÿ", "ç”¢å“åç¨±", "å€‰åˆ¥ä»£è™Ÿ", "å€‰åˆ¥åç¨±"],
    "ç”¢å“éŠ·å”®ç´°ç¯€": ["æ•¸é‡", "å–®ä½", "å–®åƒ¹", "å°è¨ˆ", "æˆæœ¬ç¸½å€¼", "ç”¢å“æ¯›åˆ©", "ç”¢å“æ¯›åˆ©ç‡", "éŠ·å”®å–®åƒ¹1", "ç²¾æº–æˆæœ¬", "ç²¾æº–æ¯›åˆ©"],
    "å…¶ä»–": ["å–®ä½ç®¡éŠ·æˆæœ¬", "ç®¡éŠ·æˆæœ¬åˆè¨ˆ"]
}

# Create sample data for reference and download
sample_data = {
    "éŠ·è²¨å–®è™Ÿ": ["S202407001", "S202407001", "S202407002", "S202407002"],
    "è¨‚å–®å–®è™Ÿ": ["O202407001", "O202407001", "O202407002", "O202407002"],
    "éŠ·è²¨æ—¥æœŸ": ["2024/07/01", "2024/07/01", "2024/07/05", "2024/07/05"],
    "å®¢æˆ¶ä»£è™Ÿ": ["C001", "C001", "C002", "C002"],
    "å®¢æˆ¶åç¨±": ["å¯µç‰©æ¨‚åœ’", "å¯µç‰©æ¨‚åœ’", "æ¯›å­©ä¹‹å®¶", "æ¯›å­©ä¹‹å®¶"],
    "éƒ¨é–€ä»£è™Ÿ": ["D01", "D01", "D01", "D01"],
    "éƒ¨é–€åç¨±": ["éŠ·å”®éƒ¨", "éŠ·å”®éƒ¨", "éŠ·å”®éƒ¨", "éŠ·å”®éƒ¨"],
    "ç™¼ç¥¨è™Ÿç¢¼": ["IV240701", "IV240701", "IV240705", "IV240705"],
    "æœªç¨…å°è¨ˆ": [3000, 3000, 2500, 2500],
    "ç‡Ÿæ¥­ç¨…": [150, 150, 125, 125],
    "ç¸½è¨ˆé‡‘é¡": [3150, 3150, 2625, 2625],
    "ç”¢å“ä»£è™Ÿ": ["P001", "P002", "P001", "P003"],
    "ç”¢å“åç¨±": ["ç‹—ç³§1kg", "è²“ç³§1kg", "ç‹—ç³§1kg", "è²“ç©å…·"],
    "å€‰åˆ¥ä»£è™Ÿ": ["W01", "W01", "W01", "W02"],
    "å€‰åˆ¥åç¨±": ["ä¸»å€‰", "ä¸»å€‰", "ä¸»å€‰", "é…ä»¶å€‰"],
    "æ•¸é‡": [10, 5, 8, 3],
    "å–®ä½": ["åŒ…", "åŒ…", "åŒ…", "å€‹"],
    "å–®åƒ¹": [200, 250, 200, 300],
    "å°è¨ˆ": [2000, 1250, 1600, 900],
    "ç²¾æº–æˆæœ¬": [1400, 900, 1120, 500],
    "ç²¾æº–æ¯›åˆ©": [600, 350, 480, 400]
}

# Create a sample DataFrame with key columns
sample_df = pd.DataFrame(sample_data)

# Divider
st.markdown("---")

# Add sidebar information
st.sidebar.title("è³‡æ–™ä¾†æºé¸æ“‡")

# Add help section with collapsible content
with st.sidebar.expander("â“ æª”æ¡ˆæ ¼å¼èªªæ˜"):
    st.write("""
    ### éŠ·è²¨æª”æ¡ˆè¦æ±‚
    - æª”æ¡ˆé¡å‹: Excel (.xlsx)
    - éŠ·è²¨æª”æ¡ˆæ‡‰åŒ…å«å®¢æˆ¶è³‡è¨Šã€ç”¢å“è³‡è¨Šã€éŠ·å”®æ•¸é‡åŠé‡‘é¡ç­‰æ¬„ä½
    - æª”æ¡ˆåç¨±å»ºè­°åŒ…å«å¹´æœˆï¼Œä¾‹å¦‚: `sales_202407.xlsx`
    
    ### BC æª”æ¡ˆè¦æ±‚
    - æª”æ¡ˆé¡å‹: Excel (.xlsx)
    - æ‡‰åŒ…å«ç”¢å“ä»£è™Ÿã€åº«å­˜æ•¸é‡ç­‰æ¬„ä½
    
    ### å¸¸è¦‹å•é¡Œ
    1. **ç¼ºå°‘æ¬„ä½**: å¦‚æœæç¤ºç¼ºå°‘æ¬„ä½ï¼Œè«‹æª¢æŸ¥æ‚¨çš„æª”æ¡ˆæ˜¯å¦åŒ…å«æ‰€æœ‰å¿…è¦æ¬„ä½
    2. **æ¬„ä½åç¨±ä¸åŒ¹é…**: è«‹ç¢ºä¿æ¬„ä½åç¨±èˆ‡ç³»çµ±éœ€æ±‚ä¸€è‡´
    3. **æª”æ¡ˆæœªé¡¯ç¤º**: è«‹ç¢ºä¿æª”æ¡ˆåç¨±ä¸­åŒ…å«å¹´æœˆæ¨™è¨˜
    """)

data_source = st.sidebar.radio(
    "é¸æ“‡æ•¸æ“šä¾†æºæ–¹å¼",
    ["ä¸Šå‚³æ–°æª”æ¡ˆ", "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ"]
)

# Add additional guidance in sidebar
if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ":
    with st.sidebar.expander("ğŸ“Š æ•¸æ“šæ ¼å¼ç¯„ä¾‹"):
        st.code("""
éŠ·è²¨å–®è™Ÿ    éŠ·è²¨æ—¥æœŸ    å®¢æˆ¶ä»£è™Ÿ    å®¢æˆ¶åç¨±    ç”¢å“ä»£è™Ÿ    ç”¢å“åç¨±    æ•¸é‡    å–®åƒ¹    å°è¨ˆ
S202301001  2023/01/05  C001       å¯µç‰©æ¨‚åœ’    P001       ç‹—ç³§1kg    10     200     2000
S202301001  2023/01/05  C001       å¯µç‰©æ¨‚åœ’    P002       è²“ç³§1kg    5      250     1250
S202301002  2023/01/10  C002       æ¯›å­©ä¹‹å®¶    P003       å¯µç‰©ç©å…·    8      150     1200
        """)

# Initialize session state for file tracking if it doesn't exist
if 'saved_sales_files' not in st.session_state:
    st.session_state.saved_sales_files = []
if 'saved_bc_file' not in st.session_state:
    st.session_state.saved_bc_file = None

# Different UI based on selected data source
if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ":
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ä¸Šå‚³éŠ·è²¨æª”æ¡ˆ")
        sales_files = st.file_uploader("ä¸Šå‚³éŠ·è²¨å–®æ¯›åˆ©åˆ†æ Excelï¼ˆå¯å¤šé¸ï¼‰", type=['xlsx'], accept_multiple_files=True)
        
        # Save uploaded sales files
        if sales_files:
            st.session_state.saved_sales_files = []
            for file in sales_files:
                file_path = save_uploaded_file(file, SALES_DIR)
                st.session_state.saved_sales_files.append({"name": file.name, "path": file_path})
    
    with col2:
        st.subheader("ä¸Šå‚³ BC è³‡æ–™")
        bc_file = st.file_uploader("ä¸Šå‚³ BC SKU è³‡æ–™ Excelï¼ˆå–®ä¸€ï¼‰", type=['xlsx'])
        
        # Save uploaded BC file
        if bc_file:
            file_path = save_uploaded_file(bc_file, BC_DIR)
            st.session_state.saved_bc_file = {"name": bc_file.name, "path": file_path}
    
    # Use the uploaded files directly
    sales_data_source = sales_files if sales_files else []
    bc_data_source = bc_file if bc_file else None

else:  # Use previously uploaded files
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("é¸æ“‡å·²ä¸Šå‚³çš„éŠ·è²¨æª”æ¡ˆ")
        available_sales_files = get_file_list(SALES_DIR, ".xlsx")
        
        if not available_sales_files:
            st.info("å°šæœªä¸Šå‚³ä»»ä½•éŠ·è²¨æª”æ¡ˆ")
            sales_data_source = []
        else:
            # Group files by month for easier selection
            file_options = [f"{file['name']}" for file in available_sales_files]
            selected_sales_files = st.multiselect("é¸æ“‡éŠ·è²¨æª”æ¡ˆ", file_options)
            
            # Map selected file names to their paths
            sales_data_source = []
            for selected in selected_sales_files:
                for file in available_sales_files:
                    if file['name'] == selected:
                        sales_data_source.append(file['path'])
    
    with col2:
        st.subheader("é¸æ“‡å·²ä¸Šå‚³çš„ BC æª”æ¡ˆ")
        available_bc_files = get_file_list(BC_DIR, ".xlsx")
        
        if not available_bc_files:
            st.info("å°šæœªä¸Šå‚³ä»»ä½• BC æª”æ¡ˆ")
            bc_data_source = None
        else:
            file_options = [f"{file['name']}" for file in available_bc_files]
            selected_bc_file = st.selectbox("é¸æ“‡ BC æª”æ¡ˆ", file_options)
            
            # Map selected file name to its path
            bc_data_source = None
            for file in available_bc_files:
                if file['name'] == selected_bc_file:
                    bc_data_source = file['path']

# Month selection based on data source
months = []
if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ" and sales_files:
    months = extract_months_from_filenames(sales_files)
elif data_source == "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ" and sales_data_source:
    # For saved files, we need to convert paths to file objects for month extraction
    file_objects = []
    for path in sales_data_source:
        file_name = os.path.basename(path)
        file_objects.append(type('obj', (object,), {'name': file_name}))
    months = extract_months_from_filenames(file_objects)

if months:
    selected_months = st.multiselect("é¸æ“‡æœˆä»½ï¼ˆå¯è¤‡é¸ï¼‰", months)
else:
    selected_months = []

# Initialize session state for column mapping if it doesn't exist
if 'column_mapping' not in st.session_state:
    st.session_state.column_mapping = {}

# Show preview of uploaded files
st.markdown("---")
st.subheader("ğŸ“‹ ä¸Šå‚³æª”æ¡ˆé è¦½")

# Display sample of uploaded sales data if available
if (data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ" and sales_files) or (data_source == "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ" and sales_data_source):
    try:
        # Load a sample of the data
        if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ" and sales_files:
            sample_file = sales_files[0]
            sample_df = pd.read_excel(sample_file, nrows=5)
        elif data_source == "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ" and sales_data_source:
            sample_df = pd.read_excel(sales_data_source[0], nrows=5)
            
        # Display the first 5 rows
        st.write("éŠ·è²¨è³‡æ–™é è¦½ (å‰5ç­†):")
        st.dataframe(sample_df, use_container_width=True)
        
        # Check and report which required headers are present/missing using our helper function
        present_headers, missing_headers, suggestions = check_required_columns(sample_df, required_headers)
        
        # Display the header status
        if missing_headers:
            st.warning(f"**æ³¨æ„:** ä¸Šå‚³æª”æ¡ˆç¼ºå°‘ {len(missing_headers)} å€‹å¿…è¦æ¬„ä½")
            
            # Column mapping UI
            with st.expander("ğŸ”„ æ¬„ä½å°æ‡‰è¨­å®š (è™•ç†æ¬„ä½åç¨±ä¸ä¸€è‡´)", expanded=True):
                st.write("æ‚¨å¯ä»¥å°‡æª”æ¡ˆä¸­çš„æ¬„ä½å°æ‡‰åˆ°ç³»çµ±éœ€è¦çš„æ¬„ä½åç¨±:")
                
                # Create a form for column mapping
                with st.form("column_mapping_form"):
                    # Create mapping UI for each missing essential column
                    essential_cols = ['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'æ•¸é‡', 'å–®åƒ¹', 'å°è¨ˆ']
                    missing_essential = [col for col in essential_cols if col in missing_headers]
                    
                    mapping_dict = {}
                    file_columns = list(sample_df.columns)
                    
                    if missing_essential:
                        st.write("**å¿…è¦æ¬„ä½å°æ‡‰:**")
                        for col in missing_essential:
                            suggested_options = suggestions.get(col, [])
                            # Prepend suggestions to the options list
                            options = [""] + suggested_options + [c for c in file_columns if c not in suggested_options]
                            mapping_dict[col] = st.selectbox(
                                f"è«‹é¸æ“‡å°æ‡‰ '{col}' çš„æ¬„ä½:",
                                options,
                                index=0 if not suggested_options else 1
                            )
                    
                    # Allow mapping for other missing columns
                    other_missing = [col for col in missing_headers if col not in missing_essential]
                    if other_missing and len(other_missing) <= 5:  # Only show if few missing columns
                        st.write("**å…¶ä»–æ¬„ä½å°æ‡‰:**")
                        for col in other_missing:
                            suggested_options = suggestions.get(col, [])
                            options = [""] + suggested_options + [c for c in file_columns if c not in suggested_options]
                            mapping_dict[col] = st.selectbox(
                                f"è«‹é¸æ“‡å°æ‡‰ '{col}' çš„æ¬„ä½:",
                                options,
                                index=0 if not suggested_options else 1
                            )
                    
                    # Submit button for the mapping
                    submitted = st.form_submit_button("æ‡‰ç”¨æ¬„ä½å°æ‡‰")
                    
                    if submitted:
                        # Filter out empty mappings
                        final_mapping = {k: v for k, v in mapping_dict.items() if v}
                        if final_mapping:
                            # Create a reversed mapping (original_column -> required_column)
                            reversed_mapping = {v: k for k, v in final_mapping.items()}
                            st.session_state.column_mapping = reversed_mapping
                            st.success(f"âœ… å·²è¨­å®š {len(final_mapping)} å€‹æ¬„ä½å°æ‡‰")
                        else:
                            st.info("æ²’æœ‰è¨­å®šä»»ä½•æ¬„ä½å°æ‡‰")
                
                # Show current mappings if any
                if st.session_state.column_mapping:
                    st.write("**ç›®å‰çš„æ¬„ä½å°æ‡‰:**")
                    mapping_items = []
                    for orig_col, mapped_col in st.session_state.column_mapping.items():
                        mapping_items.append({
                            "åŸå§‹æ¬„ä½": orig_col,
                            "å°æ‡‰è‡³": mapped_col
                        })
                    st.dataframe(pd.DataFrame(mapping_items), use_container_width=True)
                    
                    if st.button("æ¸…é™¤æ‰€æœ‰å°æ‡‰"):
                        st.session_state.column_mapping = {}
                        st.rerun()
            
            # Create a DataFrame to show missing columns and suggestions
            missing_data = []
            for col in missing_headers:
                if col in suggestions and suggestions[col]:
                    missing_data.append({
                        "ç¼ºå°‘æ¬„ä½": col,
                        "å»ºè­°å°æ‡‰": ", ".join(suggestions[col][:3])  # Show up to 3 suggestions
                    })
                else:
                    missing_data.append({
                        "ç¼ºå°‘æ¬„ä½": col,
                        "å»ºè­°å°æ‡‰": "ç„¡ç›¸ä¼¼æ¬„ä½"
                    })
            
            # Display the missing columns and suggestions in a table
            missing_df = pd.DataFrame(missing_data)
            st.dataframe(missing_df, use_container_width=True)
            
            st.info("ğŸ’¡ æç¤º: è‹¥æª”æ¡ˆä¸­ä½¿ç”¨äº†ä¸åŒçš„æ¬„ä½åç¨±ï¼Œè«‹ä½¿ç”¨ä¸Šæ–¹çš„æ¬„ä½å°æ‡‰åŠŸèƒ½ä¾†è§£æ±º")
        else:
            st.success("âœ… æ‰€æœ‰å¿…è¦æ¬„ä½éƒ½å·²å­˜åœ¨")
            
        # Show statistics of the file
        st.write(f"æª”æ¡ˆçµ±è¨ˆ: {len(sample_df.columns)} å€‹æ¬„ä½, {len(sample_df)} ç­†è³‡æ–™ (å…±é¡¯ç¤ºå‰5ç­†)")
            
    except Exception as e:
        st.error(f"ç„¡æ³•è®€å–ä¸Šå‚³æª”æ¡ˆé è¦½: {e}")
else:
    st.info("è«‹ä¸Šå‚³æª”æ¡ˆä»¥æŸ¥çœ‹é è¦½")

st.markdown("---")

# Display different sections based on the current selection
if st.session_state.current_section == "å» å•†ç”¢å“æŸ¥è©¢":
    st.header("ğŸ­ å» å•†ç”¢å“æŸ¥è©¢")
    
    # Get BC file list
    bc_files_list = get_file_list(BC_DIR, ".xlsx")
    
    if not bc_files_list:
        st.warning("è«‹å…ˆä¸Šå‚³ BC æª”æ¡ˆå†ä½¿ç”¨æ­¤åŠŸèƒ½")
    else:
        # Select BC file to use
        file_options = [f"{file['name']}" for file in bc_files_list]
        selected_bc_file = st.selectbox("é¸æ“‡ BC æª”æ¡ˆ", file_options, key="bc_file_for_vendor")
        
        # Load the selected BC file
        bc_data_path = None
        for file in bc_files_list:
            if file['name'] == selected_bc_file:
                bc_data_path = file['path']
                break
                
        if bc_data_path:
            try:
                bc_df = pd.read_excel(bc_data_path)
                
                # Check if BC file has vendor information
                if 'å» å•†ç°¡ç¨±' in bc_df.columns:
                    # Get unique vendor names and sort them alphabetically
                    vendors = sorted(bc_df['å» å•†ç°¡ç¨±'].dropna().unique().tolist())
                    
                    if vendors:
                        # Create a dropdown for vendor selection
                        selected_vendor = st.selectbox(
                            "é¸æ“‡å» å•†æŸ¥çœ‹å…¶æ‰€æœ‰ç”¢å“:",
                            ["è«‹é¸æ“‡..."] + vendors,
                            key="vendor_selector_standalone"
                        )
                        
                        if selected_vendor != "è«‹é¸æ“‡...":
                            # Filter products by the selected vendor
                            vendor_products = bc_df[bc_df['å» å•†ç°¡ç¨±'] == selected_vendor].copy()
                            
                            # Show the number of products
                            st.write(f"**{selected_vendor}** å…±æœ‰ **{len(vendor_products)}** é …ç”¢å“")
                            
                            # Create tabs for different views of vendor products
                            vendor_tab1, vendor_tab2 = st.tabs(["ç”¢å“åŸºæœ¬è³‡è¨Š", "åƒ¹æ ¼èˆ‡åº«å­˜è³‡è¨Š"])
                            
                            with vendor_tab1:
                                # Sort by product code
                                vendor_products_sorted = vendor_products.sort_values('ç”¢å“ä»£è™Ÿ')
                                
                                # Clean up the display columns - basic product info
                                basic_columns = ['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'å–®ä½', 'å» å•†ç°¡ç¨±']
                                display_columns = [col for col in basic_columns if col in vendor_products_sorted.columns]
                                
                                # Add any additional description columns if they exist
                                for col in vendor_products_sorted.columns:
                                    if 'èªªæ˜' in col or 'æè¿°' in col:
                                        if col not in display_columns:
                                            display_columns.append(col)
                                
                                # Display the table
                                st.dataframe(vendor_products_sorted[display_columns], use_container_width=True)
                                
                            with vendor_tab2:
                                # Sort by inventory level
                                if 'æ•¸é‡' in vendor_products.columns:
                                    vendor_products_sorted = vendor_products.sort_values('æ•¸é‡', ascending=False)
                                else:
                                    vendor_products_sorted = vendor_products.sort_values('ç”¢å“ä»£è™Ÿ')
                                
                                # Display columns focused on inventory and pricing
                                inventory_columns = ['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'å–®ä½']
                                
                                # Add inventory column if it exists
                                if 'æ•¸é‡' in vendor_products_sorted.columns:
                                    inventory_columns.append('æ•¸é‡')
                                
                                # Add any price or cost columns if they exist
                                for col in vendor_products_sorted.columns:
                                    if 'åƒ¹æ ¼' in col or 'æˆæœ¬' in col or 'å”®åƒ¹' in col:
                                        inventory_columns.append(col)
                                
                                # Display the table
                                st.dataframe(vendor_products_sorted[inventory_columns], use_container_width=True)
                            
                            # Add download button for filtered data
                            csv_vendor_products = vendor_products.to_csv(index=False).encode('utf-8-sig')
                            st.download_button(
                                f"ä¸‹è¼‰ {selected_vendor} ç”¢å“è³‡æ–™",
                                csv_vendor_products,
                                f"{selected_vendor}_products.csv",
                                "text/csv"
                            )
                    else:
                        st.warning("BCæª”æ¡ˆä¸­æ²’æœ‰æ‰¾åˆ°å» å•†è³‡è¨Š")
                else:
                    st.warning("BCæª”æ¡ˆä¸­ç¼ºå°‘'å» å•†ç°¡ç¨±'æ¬„ä½ï¼Œç„¡æ³•é€²è¡Œå» å•†ç”¢å“æŸ¥è©¢")
            except Exception as e:
                st.error(f"è®€å– BC æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        else:
            st.error("ç„¡æ³•è¼‰å…¥é¸å®šçš„ BC æª”æ¡ˆ")

elif st.session_state.current_section == "ç”¢å“åˆ†æ":
    st.header("ğŸ“Š ç”¢å“éŠ·å”®åˆ†æ")
    
    # Get sales file list
    sales_files_list = get_file_list(SALES_DIR, ".xlsx")
    
    if not sales_files_list:
        st.warning("è«‹å…ˆä¸Šå‚³éŠ·è²¨æª”æ¡ˆå†ä½¿ç”¨æ­¤åŠŸèƒ½")
    else:
        # Select files to analyze
        col1, col2 = st.columns([3, 1])
        
        with col1:
            file_options = [f"{file['name']}" for file in sales_files_list]
            selected_files = st.multiselect("é¸æ“‡è¦åˆ†æçš„éŠ·è²¨æª”æ¡ˆ", file_options, key="sales_file_for_analysis")
        
        with col2:
            analyze_button = st.button("é–‹å§‹åˆ†æ", use_container_width=True)
        
        if analyze_button and selected_files:
            with st.spinner("åˆ†æéŠ·å”®è³‡æ–™ä¸­..."):
                # Load the selected files
                sales_data_paths = []
                for selected in selected_files:
                    for file in sales_files_list:
                        if file['name'] == selected:
                            sales_data_paths.append(file['path'])
                
                # Extract months from the selected files
                file_objects = []
                for path in sales_data_paths:
                    file_name = os.path.basename(path)
                    file_objects.append(type('obj', (object,), {'name': file_name}))
                
                months = extract_months_from_filenames(file_objects)
                
                # Load and process the sales data
                sales_df = load_sales_data(sales_data_paths, months, is_path=True)
                
                if sales_df.empty:
                    st.error("ç„¡æ³•è¼‰å…¥éŠ·å”®è³‡æ–™ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚")
                else:
                    # Generate the product summary
                    summary_df = generate_monthly_summary(sales_df)
                    
                    # Create tabs for different analyses
                    analysis_tab1, analysis_tab2, analysis_tab3 = st.tabs(["éŠ·å”®é¡åˆ†æ", "æ¯›åˆ©åˆ†æ", "è¶¨å‹¢åˆ†æ"])
                    
                    with analysis_tab1:
                        st.subheader("ğŸ’° ç”¢å“éŠ·å”®é¡åˆ†æ")
                        
                        # Top 10 products by sales
                        top10_sales = summary_df.sort_values(by='å°è¨ˆ', ascending=False).head(10)
                        
                        # Format for display
                        display_df = top10_sales.copy()
                        display_df['å°è¨ˆ'] = display_df['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                        
                        st.write("#### å‰10å¤§éŠ·å”®ç”¢å“")
                        st.dataframe(display_df[['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'æ•¸é‡', 'å°è¨ˆ']], use_container_width=True)
                        
                        # Create a bar chart
                        import altair as alt
                        
                        # Prepare data for chart
                        chart_data = pd.DataFrame({
                            'ç”¢å“': top10_sales['ç”¢å“åç¨±'],
                            'éŠ·å”®é¡': top10_sales['å°è¨ˆ']
                        })
                        
                        # Create and display the chart
                        chart = alt.Chart(chart_data).mark_bar().encode(
                            y=alt.Y('ç”¢å“:N', sort='-x', title=None),
                            x=alt.X('éŠ·å”®é¡:Q', title='éŠ·å”®é¡'),
                            color=alt.value('#4CAF50')
                        ).properties(
                            height=400,
                            title='å‰10å¤§ç”¢å“éŠ·å”®é¡'
                        )
                        
                        st.altair_chart(chart, use_container_width=True)
                    
                    with analysis_tab2:
                        st.subheader("ğŸ’ ç”¢å“æ¯›åˆ©åˆ†æ")
                        
                        # Top 10 products by profit
                        top10_profit = summary_df.sort_values(by='ç²¾æº–æ¯›åˆ©', ascending=False).head(10)
                        
                        # Calculate profit margins
                        top10_profit['æ¯›åˆ©ç‡'] = top10_profit.apply(
                            lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                            axis=1
                        )
                        
                        # Format for display
                        display_df = top10_profit.copy()
                        display_df['å°è¨ˆ'] = display_df['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                        display_df['ç²¾æº–æ¯›åˆ©'] = display_df['ç²¾æº–æ¯›åˆ©'].apply(lambda x: f"${x:,.0f}")
                        display_df['æ¯›åˆ©ç‡'] = display_df['æ¯›åˆ©ç‡'].apply(lambda x: f"{x:.1f}%")
                        
                        st.write("#### å‰10å¤§æ¯›åˆ©ç”¢å“")
                        st.dataframe(display_df[['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'å°è¨ˆ', 'ç²¾æº–æ¯›åˆ©', 'æ¯›åˆ©ç‡']], use_container_width=True)
                        
                        # Create a scatter plot
                        import plotly.express as px
                        
                        # Filter products with significant sales for better visualization
                        scatter_data = summary_df[summary_df['å°è¨ˆ'] > 1000].copy()
                        scatter_data['æ¯›åˆ©ç‡'] = scatter_data.apply(
                            lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                            axis=1
                        )
                        
                        
                        # Calculate absolute profit values for sizing to avoid negative size values
                        scatter_data['ç²¾æº–æ¯›åˆ©_abs'] = scatter_data['ç²¾æº–æ¯›åˆ©'].abs()

                        fig = px.scatter(
                            scatter_data,
                            x='å°è¨ˆ',
                            y='æ¯›åˆ©ç‡',
                            size='ç²¾æº–æ¯›åˆ©_abs',  # Use absolute values for size
                            color='ç²¾æº–æ¯›åˆ©',
                            hover_name='ç”¢å“åç¨±',
                            title='ç”¢å“éŠ·å”®é¡ vs æ¯›åˆ©ç‡åˆ†æ',
                            labels={
                                'å°è¨ˆ': 'éŠ·å”®é¡',
                                'æ¯›åˆ©ç‡': 'æ¯›åˆ©ç‡ (%)',
                                'ç²¾æº–æ¯›åˆ©': 'æ¯›åˆ©é¡'
                            },
                            color_continuous_scale=px.colors.sequential.Viridis
                        )
                        
                        fig.update_layout(
                            xaxis=dict(title='éŠ·å”®é¡', tickprefix='$'),
                            yaxis=dict(title='æ¯›åˆ©ç‡ (%)')
                        )
                        
                        st.plotly_chart(fig, use_container_width=True)
                        
                        st.markdown("""
                        **åˆ†æèªªæ˜ï¼š**
                        - æ³¡æ³¡å¤§å°å’Œé¡è‰²ä»£è¡¨æ¯›åˆ©é¡
                        - å³ä¸Šæ–¹çš„ç”¢å“æ˜¯é«˜éŠ·å”®é¡å’Œé«˜æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œé€™äº›æ˜¯æœ€ç†æƒ³çš„ç”¢å“
                        - å·¦ä¸Šæ–¹çš„ç”¢å“æ˜¯ä½éŠ·å”®é¡ä½†é«˜æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œå¯èƒ½æœ‰å¢é•·æ½›åŠ›
                        - å³ä¸‹æ–¹çš„ç”¢å“æ˜¯é«˜éŠ·å”®é¡ä½†ä½æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œå¯èƒ½éœ€è¦å„ªåŒ–å®šåƒ¹
                        """)
                    
                    with analysis_tab3:
                        st.subheader("ğŸ“ˆ ç”¢å“è¶¨å‹¢åˆ†æ")
                        
                        if 'å€‰åˆ¥åç¨±' in summary_df.columns:
                            # Group by warehouse category
                            category_summary = summary_df.groupby('å€‰åˆ¥åç¨±').agg({
                                'å°è¨ˆ': 'sum',
                                'ç²¾æº–æ¯›åˆ©': 'sum',
                                'ç”¢å“ä»£è™Ÿ': 'nunique'
                            }).reset_index()
                            
                            # Calculate profit margin
                            category_summary['æ¯›åˆ©ç‡'] = category_summary.apply(
                                lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                                axis=1
                            )
                            
                            # Rename columns for clarity
                            category_summary.rename(columns={
                                'ç”¢å“ä»£è™Ÿ': 'ç”¢å“æ•¸é‡'
                            }, inplace=True)
                            
                            # Format for display
                            display_df = category_summary.copy()
                            display_df['å°è¨ˆ'] = display_df['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                            display_df['ç²¾æº–æ¯›åˆ©'] = display_df['ç²¾æº–æ¯›åˆ©'].apply(lambda x: f"${x:,.0f}")
                            display_df['æ¯›åˆ©ç‡'] = display_df['æ¯›åˆ©ç‡'].apply(lambda x: f"{x:.1f}%")
                            
                            st.write("#### ç”¢å“é¡åˆ¥åˆ†æ")
                            st.dataframe(display_df, use_container_width=True)
                            
                            # Create a pie chart
                            import plotly.express as px
                            
                            fig = px.pie(
                                category_summary,
                                values='å°è¨ˆ',
                                names='å€‰åˆ¥åç¨±',
                                title='å„é¡åˆ¥éŠ·å”®é¡ä½”æ¯”',
                                hover_data=['æ¯›åˆ©ç‡', 'ç”¢å“æ•¸é‡']
                            )
                            
                            fig.update_traces(
                                textinfo='percent+label',
                                hovertemplate='<b>%{label}</b><br>éŠ·å”®é¡: $%{value:,.0f}<br>æ¯›åˆ©ç‡: %{customdata[0]:.1f}%<br>ç”¢å“æ•¸é‡: %{customdata[1]}<extra></extra>'
                            )
                            
                            st.plotly_chart(fig, use_container_width=True)
                        else:
                            st.warning("æ•¸æ“šä¸­ç¼ºå°‘å€‰åˆ¥åç¨±è³‡è¨Šï¼Œç„¡æ³•é€²è¡Œé¡åˆ¥åˆ†æã€‚")
                        
                        # Download button for the full summary
                        csv_summary = summary_df.to_csv(index=False).encode('utf-8-sig')
                        st.download_button(
                            "ğŸ’¾ ä¸‹è¼‰å®Œæ•´ç”¢å“éŠ·å”®åˆ†æ CSV",
                            csv_summary,
                            f"product_analysis_{'_'.join(months)}.csv",
                            "text/csv"
                        )
        elif not selected_files and analyze_button:
            st.warning("è«‹é¸æ“‡è‡³å°‘ä¸€å€‹éŠ·è²¨æª”æ¡ˆé€²è¡Œåˆ†æ")
    
elif st.session_state.current_section == "BC è³‡æ–™æ¯”å°":
    st.header("ğŸ”„ BC è³‡æ–™æ¯”å°")
    
    # Get BC file list
    bc_files_list = get_file_list(BC_DIR, ".xlsx")
    sales_files_list = get_file_list(SALES_DIR, ".xlsx")
    
    if not bc_files_list:
        st.warning("è«‹å…ˆä¸Šå‚³ BC æª”æ¡ˆå†ä½¿ç”¨æ­¤åŠŸèƒ½")
    elif not sales_files_list:
        st.warning("è«‹å…ˆä¸Šå‚³éŠ·è²¨æª”æ¡ˆå†ä½¿ç”¨æ­¤åŠŸèƒ½")
    else:
        # Select files to compare
        col1, col2 = st.columns(2)
        
        with col1:
            bc_file_options = [f"{file['name']}" for file in bc_files_list]
            selected_bc_file = st.selectbox("é¸æ“‡ BC æª”æ¡ˆ", bc_file_options, key="bc_file_for_compare")
        
        with col2:
            sales_file_options = [f"{file['name']}" for file in sales_files_list]
            selected_sales_file = st.selectbox("é¸æ“‡éŠ·è²¨æª”æ¡ˆ", sales_file_options, key="sales_file_for_compare")
        
        if st.button("åŸ·è¡Œæ¯”å°åˆ†æ"):
            st.info("è³‡æ–™æ¯”å°åˆ†æä¸­...")
            # Load and compare files
            # This will be implemented later

elif st.session_state.current_section == "è¨‚å–®èª¿é–±":
    st.header("ğŸ“ è¨‚å–®èª¿é–±")
    
    # Add order lookup functionality
    st.info("è¨‚å–®èª¿é–±åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­...")
    
elif st.session_state.current_section == "ç”Ÿæˆå ±è¡¨":
    # Generate report button
    has_sales_data = (data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ" and sales_files) or (data_source == "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ" and sales_data_source)

    if st.button("â–¶ï¸ ç”Ÿæˆå ±è¡¨") and has_sales_data and selected_months:
        with st.spinner("è™•ç†è³‡æ–™ä¸­..."):
            try:
                # Use the column mapping from session state if available
                column_mapping = st.session_state.column_mapping if 'column_mapping' in st.session_state else None
                
                # Load sales data based on the data source
                if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ":
                    sales_df = load_sales_data(sales_files, selected_months, is_path=False, column_mapping=column_mapping)
                else:  # Using previously uploaded files
                    sales_df = load_sales_data(sales_data_source, selected_months, is_path=True, column_mapping=column_mapping)

                if sales_df.empty:
                    st.error("æ²’æœ‰æ‰¾åˆ°ç¬¦åˆé¸æ“‡æœˆä»½çš„è³‡æ–™ï¼Œè«‹æª¢æŸ¥æ‚¨çš„é¸æ“‡ã€‚")
                else:
                    # 1. Create tabs for different analyses with è¨‚å–®æ‘˜è¦ as the first tab
                    order_tab, product_tab, bc_tab = st.tabs(["è¨‚å–®æ‘˜è¦", "ç”¢å“åˆ†æ", "BC è³‡æ–™æ¯”å°"])
                    sales_df = load_sales_data(sales_data_source, selected_months, is_path=True, column_mapping=column_mapping)

                if sales_df.empty:
                    st.error("æ²’æœ‰æ‰¾åˆ°ç¬¦åˆé¸æ“‡æœˆä»½çš„è³‡æ–™ï¼Œè«‹æª¢æŸ¥æ‚¨çš„é¸æ“‡ã€‚")
                else:
                    # 1. Create tabs for different analyses with è¨‚å–®æ‘˜è¦ as the first tab
                    order_tab, product_tab, bc_tab = st.tabs(["è¨‚å–®æ‘˜è¦", "ç”¢å“åˆ†æ", "BC è³‡æ–™æ¯”å°"])
                
                with product_tab:
                    st.subheader(f"ğŸ§¾ {'ã€'.join(selected_months)} ç”¢å“éŠ·å”®å½™ç¸½è¡¨")
                    
                    # Generate the product summary
                    summary_df = generate_monthly_summary(sales_df)
                    
                    # Create tabs for different product analyses
                    product_tab1, product_tab2, product_tab3 = st.tabs(["å‰20å¤§ç”¢å“", "ç”¢å“åˆ†æåœ–è¡¨", "å®Œæ•´ç”¢å“åˆ—è¡¨"])
                    
                    # Add debug mode toggle at the top level of the product tab
                    show_debug = st.checkbox("é¡¯ç¤ºè¨ˆç®—é©—è­‰è³‡è¨Š", value=False, help="é–‹å•Ÿæ­¤é¸é …å¯ä»¥æª¢è¦–æ•¸æ“šè¨ˆç®—éç¨‹å’Œé©—è­‰è³‡è¨Š")
                    
                    with product_tab1:
                        st.markdown("### ğŸ† å‰20å¤§éŠ·å”®ç”¢å“")
                        
                        if not summary_df.empty:
                            # Get top 20 products by sales amount
                            top_products = summary_df.sort_values(by='å°è¨ˆ', ascending=False).head(20).copy()
                            
                            # Format for display
                            display_df = top_products.copy()
                            display_df['å°è¨ˆ'] = display_df['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                            display_df['ç²¾æº–æˆæœ¬'] = display_df['ç²¾æº–æˆæœ¬'].apply(lambda x: f"${x:,.0f}")
                            display_df['ç²¾æº–æ¯›åˆ©'] = display_df['ç²¾æº–æ¯›åˆ©'].apply(lambda x: f"${x:,.0f}")
                            
                            # Add rank column
                            display_df.insert(0, 'æ’å', range(1, len(display_df) + 1))
                            
                            # Display as a table
                            st.markdown("#### å‰20å¤§ç”¢å“éŠ·å”®è¡¨")
                            st.dataframe(display_df[['æ’å', 'ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'æ•¸é‡', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©']], use_container_width=True)
                            
                            # Create two columns for the charts
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                # Create a bar chart for top products
                                st.markdown("#### å‰20å¤§ç”¢å“éŠ·å”®é¡")
                                
                                # Use Altair to create a bar chart
                                import altair as alt
                                
                                # Prepare data for chart
                                chart_data = pd.DataFrame({
                                    'ç”¢å“': top_products['ç”¢å“åç¨±'] + ' (' + top_products['ç”¢å“ä»£è™Ÿ'] + ')',
                                    'éŠ·å”®é¡': top_products['å°è¨ˆ']
                                })
                                
                                # Create the chart
                                chart = alt.Chart(chart_data).mark_bar().encode(
                                    y=alt.Y('ç”¢å“:N', sort='-x', title=None),
                                    x=alt.X('éŠ·å”®é¡:Q', title='éŠ·å”®é¡'),
                                    color=alt.value('#4CAF50'),
                                    tooltip=['ç”¢å“', 'éŠ·å”®é¡']
                                ).properties(
                                    height=400
                                )
                                
                                # Add text labels
                                text = chart.mark_text(
                                    align='left',
                                    baseline='middle',
                                    dx=5,
                                    color='black'
                                ).encode(
                                    text=alt.Text('éŠ·å”®é¡', format='$,.0f')
                                )
                                
                                # Combine chart and text
                                final_chart = (chart + text).configure_view(
                                    strokeWidth=0
                                ).configure_axis(
                                    labelFontSize=12,
                                    titleFontSize=14,
                                    grid=False
                                )
                                
                                # Display the chart
                                st.altair_chart(final_chart, use_container_width=True)
                            
                            with col2:
                                # Create a pie chart for top products
                                st.markdown("#### å‰20å¤§ç”¢å“éŠ·å”®ä½”æ¯”")
                                
                                # Calculate total sales for all products first
                                total_sales_all = summary_df['å°è¨ˆ'].sum()
                                
                                # Calculate percentage for each product based on total sales
                                top_products['ä½”æ¯”'] = top_products['å°è¨ˆ'] / total_sales_all * 100
                                
                                # Create labels with percentage and include product code
                                top_products['æ¨™ç±¤'] = top_products.apply(
                                    lambda x: f"{x['ç”¢å“åç¨±']} ({x['ä½”æ¯”']:.1f}%)",
                                    axis=1
                                )
                                
                                # Only show debug info if checkbox is checked
                                if show_debug:
                                    st.write(f"ç¸½éŠ·å”®é¡: ${total_sales_all:,.0f}")
                                    st.write(f"å‰20å¤§ç”¢å“éŠ·å”®é¡: ${top_products['å°è¨ˆ'].sum():,.0f} ({top_products['å°è¨ˆ'].sum()/total_sales_all*100:.1f}%)")
                                
                                # Create a pie chart using Plotly
                                import plotly.express as px
                                
                                fig = px.pie(
                                    top_products,
                                    values='å°è¨ˆ',
                                    names='æ¨™ç±¤',
                                    title='å‰20å¤§ç”¢å“éŠ·å”®ä½”æ¯”',
                                    color_discrete_sequence=px.colors.qualitative.Pastel
                                )
                                
                                # Update layout for better readability
                                fig.update_traces(
                                    textposition='inside',
                                    textinfo='percent+label',
                                    hoverinfo='label+percent+value',
                                    textfont_size=10,
                                    marker=dict(line=dict(color='#FFFFFF', width=1))
                                )
                                
                                # Improve layout
                                fig.update_layout(
                                    showlegend=False,
                                    margin=dict(t=50, b=20, l=0, r=0)
                                )
                                
                                # Display the chart
                                st.plotly_chart(fig, use_container_width=True)
                                
                                # Add a note about the chart
                                st.info("ğŸ’¡ åœ“é¤…åœ–é¡¯ç¤ºå‰20å¤§ç”¢å“çš„éŠ·å”®é¡ä½”æ¯”ï¼Œå¯ä»¥é€šéæ‡¸åœåœ¨å„å€‹éƒ¨åˆ†ä¸ŠæŸ¥çœ‹è©³ç´°ä¿¡æ¯ã€‚")
                    
                    with product_tab2:
                        st.markdown("### ğŸ“Š ç”¢å“åˆ†æåœ–è¡¨")
                        
                        # Create multiple useful visualizations for product analysis
                        if not summary_df.empty:
                            # Create a selection for visualization type
                            viz_type = st.selectbox(
                                "é¸æ“‡åœ–è¡¨é¡å‹",
                                ["ç”¢å“éŠ·é‡èˆ‡éŠ·å”®é¡æ¯”è¼ƒ", "ç”¢å“æ¯›åˆ©åˆ†æ", "ç”¢å“é¡åˆ¥åˆ†æ", "ç”¢å“æˆæœ¬çµæ§‹"]
                            )
                            
                            if viz_type == "ç”¢å“éŠ·é‡èˆ‡éŠ·å”®é¡æ¯”è¼ƒ":
                                # Get top 15 products by sales for this visualization
                                top15_qty = summary_df.sort_values(by='æ•¸é‡', ascending=False).head(15)
                                
                                # Create a dual-axis chart with Plotly
                                import plotly.graph_objects as go
                                from plotly.subplots import make_subplots
                                
                                # Create subplot with secondary y-axis
                                fig = make_subplots(specs=[[{"secondary_y": True}]])
                                
                                # Add bar chart for quantity
                                fig.add_trace(
                                    go.Bar(
                                        x=top15_qty['ç”¢å“åç¨±'],
                                        y=top15_qty['æ•¸é‡'],
                                        name="éŠ·å”®æ•¸é‡",
                                        marker_color='#2196F3',
                                        hovertemplate='æ•¸é‡: %{y:,.0f}<br>ç”¢å“: %{x}<extra></extra>'
                                    ),
                                    secondary_y=False
                                )
                                
                                # Add line chart for sales amount
                                fig.add_trace(
                                    go.Scatter(
                                        x=top15_qty['ç”¢å“åç¨±'],
                                        y=top15_qty['å°è¨ˆ'],
                                        name="éŠ·å”®é¡",
                                        marker_color='#FF5722',
                                        mode='lines+markers',
                                        hovertemplate='éŠ·å”®é¡: $%{y:,.0f}<br>ç”¢å“: %{x}<extra></extra>'
                                    ),
                                    secondary_y=True
                                )
                                
                                # Set axis titles
                                fig.update_layout(
                                    title_text="å‰15å¤§ç”¢å“ï¼šéŠ·å”®æ•¸é‡ vs éŠ·å”®é¡",
                                    xaxis_title="ç”¢å“åç¨±",
                                    barmode='group',
                                    legend=dict(
                                        orientation="h",
                                        yanchor="bottom",
                                        y=1.02,
                                        xanchor="right",
                                        x=1
                                    )
                                )
                                
                                # Set y-axes titles
                                fig.update_yaxes(title_text="éŠ·å”®æ•¸é‡", secondary_y=False)
                                fig.update_yaxes(title_text="éŠ·å”®é¡", secondary_y=True)
                                
                                # Show the figure
                                st.plotly_chart(fig, use_container_width=True)
                                
                                st.markdown("""
                                **åˆ†æèªªæ˜ï¼š**
                                - æ­¤åœ–è¡¨æ¯”è¼ƒç”¢å“çš„éŠ·å”®æ•¸é‡ï¼ˆæŸ±ç‹€åœ–ï¼‰å’ŒéŠ·å”®é¡ï¼ˆæŠ˜ç·šåœ–ï¼‰
                                - æœ‰äº›ç”¢å“å¯èƒ½æ•¸é‡å°‘ä½†éŠ·å”®é¡é«˜ï¼Œè¡¨ç¤ºé€™äº›ç”¢å“å–®åƒ¹é«˜
                                - æœ‰äº›ç”¢å“å¯èƒ½æ•¸é‡å¤šä½†éŠ·å”®é¡è¼ƒä½ï¼Œè¡¨ç¤ºé€™äº›ç”¢å“å–®åƒ¹ä½
                                """)
                            
                            elif viz_type == "ç”¢å“æ¯›åˆ©åˆ†æ":
                                # Add profit margin analysis
                                # Calculate profit margin percentage with error handling
                                profit_data = summary_df.copy()
                                # Ensure we don't divide by zero
                                profit_data['æ¯›åˆ©ç‡'] = profit_data.apply(
                                    lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                                    axis=1
                                )
                                
                                # Calculate verification metrics
                                profit_data['è¨ˆç®—æ¯›åˆ©'] = profit_data['å°è¨ˆ'] - profit_data['ç²¾æº–æˆæœ¬']
                                profit_data['æ¯›åˆ©å·®ç•°'] = profit_data['ç²¾æº–æ¯›åˆ©'] - profit_data['è¨ˆç®—æ¯›åˆ©']
                                
                                # Only display verification if debug mode is on
                                if show_debug:
                                    st.write("åˆ©æ½¤é©—è­‰: ç²¾æº–æ¯›åˆ© = å°è¨ˆ - ç²¾æº–æˆæœ¬")
                                    verification_df = profit_data.head(5)[['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©', 'è¨ˆç®—æ¯›åˆ©', 'æ¯›åˆ©å·®ç•°']]
                                    st.dataframe(verification_df)
                                
                                # Get top products by profit
                                top15_profit = profit_data.sort_values(by='ç²¾æº–æ¯›åˆ©', ascending=False).head(15)
                                
                                # Create a scatter plot showing sales amount vs. profit margin
                                import plotly.express as px
                                
                                
                                # Calculate absolute profit values for sizing to avoid negative size values
                                profit_data['ç²¾æº–æ¯›åˆ©_abs'] = profit_data['ç²¾æº–æ¯›åˆ©'].abs()

                                # Create the scatter plot
                                fig = px.scatter(
                                    profit_data,
                                    x='å°è¨ˆ',
                                    y='æ¯›åˆ©ç‡',
                                    size='ç²¾æº–æ¯›åˆ©_abs',  # Use absolute values for size
                                    color='ç²¾æº–æ¯›åˆ©',
                                    hover_name='ç”¢å“åç¨±',
                                    text='ç”¢å“ä»£è™Ÿ',
                                    title='ç”¢å“éŠ·å”®é¡ vs æ¯›åˆ©ç‡åˆ†æ',
                                    labels={
                                        'å°è¨ˆ': 'éŠ·å”®é¡',
                                        'æ¯›åˆ©ç‡': 'æ¯›åˆ©ç‡ (%)',
                                        'ç²¾æº–æ¯›åˆ©': 'æ¯›åˆ©é¡'
                                    },
                                    color_continuous_scale=px.colors.sequential.Viridis
                                )
                                
                                # Improve the layout
                                fig.update_traces(
                                    textposition='top center',
                                    marker=dict(sizemin=5),
                                    selector=dict(mode='markers+text')
                                )
                                
                                fig.update_layout(
                                    xaxis=dict(title='éŠ·å”®é¡', tickprefix='$'),
                                    yaxis=dict(title='æ¯›åˆ©ç‡ (%)')
                                )
                                
                                # Display the chart
                                st.plotly_chart(fig, use_container_width=True)
                                
                                st.markdown("""
                                **åˆ†æèªªæ˜ï¼š**
                                - æ³¡æ³¡å¤§å°ä»£è¡¨æ¯›åˆ©é¡
                                - å³ä¸Šæ–¹çš„ç”¢å“æ˜¯é«˜éŠ·å”®é¡å’Œé«˜æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œé€™äº›æ˜¯æœ€ç†æƒ³çš„ç”¢å“
                                - å·¦ä¸Šæ–¹çš„ç”¢å“æ˜¯ä½éŠ·å”®é¡ä½†é«˜æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œå¯èƒ½æœ‰å¢é•·æ½›åŠ›
                                - å³ä¸‹æ–¹çš„ç”¢å“æ˜¯é«˜éŠ·å”®é¡ä½†ä½æ¯›åˆ©ç‡çš„ç”¢å“ï¼Œå¯èƒ½éœ€è¦å„ªåŒ–å®šåƒ¹
                                """)
                                
                                # Show a table of top 15 most profitable products
                                st.markdown("#### å‰15å¤§æ¯›åˆ©ç”¢å“")
                                
                                # Format for display
                                display_top_profit = top15_profit.copy()
                                display_top_profit['å°è¨ˆ'] = display_top_profit['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                                display_top_profit['ç²¾æº–æˆæœ¬'] = display_top_profit['ç²¾æº–æˆæœ¬'].apply(lambda x: f"${x:,.0f}")
                                display_top_profit['ç²¾æº–æ¯›åˆ©'] = display_top_profit['ç²¾æº–æ¯›åˆ©'].apply(lambda x: f"${x:,.0f}")
                                display_top_profit['æ¯›åˆ©ç‡'] = display_top_profit['æ¯›åˆ©ç‡'].apply(lambda x: f"{x:.1f}%")
                                
                                # Add rank column
                                display_top_profit.insert(0, 'æ’å', range(1, len(display_top_profit) + 1))
                                
                                # Display as a table
                                st.dataframe(
                                    display_top_profit[['æ’å', 'ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'æ•¸é‡', 'å°è¨ˆ', 'ç²¾æº–æ¯›åˆ©', 'æ¯›åˆ©ç‡']],
                                    use_container_width=True
                                )
                            
                            elif viz_type == "ç”¢å“é¡åˆ¥åˆ†æ":
                                st.info("è¦å•Ÿç”¨æ­¤åˆ†æï¼Œéœ€è¦åœ¨æ•¸æ“šä¸­åŒ…å«ç”¢å“é¡åˆ¥è³‡è¨Šã€‚ç›®å‰ä½¿ç”¨å€‰åˆ¥ä½œç‚ºé¡åˆ¥åˆ†æã€‚")
                                
                                # Group by warehouse (as a proxy for product category)
                                if 'å€‰åˆ¥åç¨±' in summary_df.columns:
                                    # Group by warehouse
                                    warehouse_summary = summary_df.groupby('å€‰åˆ¥åç¨±').agg({
                                        'å°è¨ˆ': 'sum',
                                        'ç²¾æº–æˆæœ¬': 'sum',
                                        'ç²¾æº–æ¯›åˆ©': 'sum',
                                        'æ•¸é‡': 'sum',
                                        'ç”¢å“ä»£è™Ÿ': 'nunique'
                                    }).reset_index()
                                    
                                    # Calculate profit margin with proper error handling
                                    warehouse_summary['æ¯›åˆ©ç‡'] = warehouse_summary.apply(
                                        lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                                        axis=1
                                    )
                                    
                                    # Add a verification column for warehouse summary
                                    warehouse_summary['è¨ˆç®—æ¯›åˆ©'] = warehouse_summary['å°è¨ˆ'] - warehouse_summary['ç²¾æº–æˆæœ¬']
                                    warehouse_summary['æ¯›åˆ©å·®ç•°'] = warehouse_summary['ç²¾æº–æ¯›åˆ©'] - warehouse_summary['è¨ˆç®—æ¯›åˆ©']
                                    
                                    # Only display verification if debug mode is on
                                    if show_debug:
                                        st.write("å€‰åˆ¥å½™ç¸½è³‡æ–™é©—è­‰:")
                                        verification_df = warehouse_summary[['å€‰åˆ¥åç¨±', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©', 'è¨ˆç®—æ¯›åˆ©', 'æ¯›åˆ©å·®ç•°']]
                                        st.dataframe(verification_df)
                                    
                                    # Rename columns for clarity
                                    warehouse_summary.rename(columns={
                                        'ç”¢å“ä»£è™Ÿ': 'ç”¢å“æ•¸é‡'
                                    }, inplace=True)
                                    
                                    # Sort by sales amount
                                    warehouse_summary = warehouse_summary.sort_values(by='å°è¨ˆ', ascending=False)
                                    
                                    # Create a treemap visualization
                                    import plotly.express as px
                                    
                                    fig = px.treemap(
                                        warehouse_summary,
                                        path=['å€‰åˆ¥åç¨±'],
                                        values='å°è¨ˆ',
                                        color='æ¯›åˆ©ç‡',
                                        hover_data=['ç²¾æº–æ¯›åˆ©', 'ç”¢å“æ•¸é‡', 'æ•¸é‡'],
                                        color_continuous_scale='RdBu',
                                        title='å€‰åˆ¥éŠ·å”®é¡åŠæ¯›åˆ©ç‡åˆ†æ'
                                    )
                                    
                                    fig.update_layout(margin=dict(t=50, l=25, r=25, b=25))
                                    fig.update_traces(
                                        hovertemplate='<b>%{label}</b><br>éŠ·å”®é¡: $%{value:,.0f}<br>æ¯›åˆ©ç‡: %{color:.1f}%<br>ç”¢å“æ•¸é‡: %{customdata[1]}<br>éŠ·å”®æ•¸é‡: %{customdata[2]:,}<extra></extra>'
                                    )
                                    
                                    # Display the chart
                                    st.plotly_chart(fig, use_container_width=True)
                                    
                                    # Show the summary table
                                    display_warehouse = warehouse_summary.copy()
                                    display_warehouse['å°è¨ˆ'] = display_warehouse['å°è¨ˆ'].apply(lambda x: f"${x:,.0f}")
                                    display_warehouse['ç²¾æº–æˆæœ¬'] = display_warehouse['ç²¾æº–æˆæœ¬'].apply(lambda x: f"${x:,.0f}")
                                    display_warehouse['ç²¾æº–æ¯›åˆ©'] = display_warehouse['ç²¾æº–æ¯›åˆ©'].apply(lambda x: f"${x:,.0f}")
                                    display_warehouse['æ¯›åˆ©ç‡'] = display_warehouse['æ¯›åˆ©ç‡'].apply(lambda x: f"{x:.1f}%")
                                    
                                    st.dataframe(display_warehouse, use_container_width=True)
                                else:
                                    st.warning("æ•¸æ“šä¸­ç¼ºå°‘å€‰åˆ¥åç¨±è³‡è¨Šï¼Œç„¡æ³•é€²è¡Œé¡åˆ¥åˆ†æã€‚")
                                    
                            elif viz_type == "ç”¢å“æˆæœ¬çµæ§‹":
                                # Select top products for cost structure analysis
                                top10_cost = summary_df.sort_values(by='å°è¨ˆ', ascending=False).head(10).copy()
                                
                                # Clean and validate the data first
                                # Verify that costs + profits = total
                                top10_cost['è¨ˆç®—æ¯›åˆ©'] = top10_cost['å°è¨ˆ'] - top10_cost['ç²¾æº–æˆæœ¬']
                                top10_cost['æ¯›åˆ©å·®ç•°'] = top10_cost['ç²¾æº–æ¯›åˆ©'] - top10_cost['è¨ˆç®—æ¯›åˆ©']
                                
                                # Only if there are discrepancies, fix them
                                has_discrepancies = top10_cost['æ¯›åˆ©å·®ç•°'].abs().sum() > 0
                                if has_discrepancies:
                                    if show_debug:
                                        st.warning("æª¢æ¸¬åˆ°æ¯›åˆ©è¨ˆç®—ä¸ä¸€è‡´ï¼Œæ­£åœ¨èª¿æ•´...")
                                    # Use calculated profit instead
                                    top10_cost['ç²¾æº–æ¯›åˆ©'] = top10_cost['è¨ˆç®—æ¯›åˆ©']
                                
                                # Calculate profit and cost components with proper error handling
                                top10_cost['æˆæœ¬æ¯”ä¾‹'] = top10_cost.apply(
                                    lambda x: (x['ç²¾æº–æˆæœ¬'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                                    axis=1
                                )
                                top10_cost['æ¯›åˆ©æ¯”ä¾‹'] = top10_cost.apply(
                                    lambda x: (x['ç²¾æº–æ¯›åˆ©'] / x['å°è¨ˆ'] * 100) if x['å°è¨ˆ'] > 0 else 0,
                                    axis=1
                                )
                                
                                # Verify sum is 100%
                                top10_cost['ç¸½æ¯”ä¾‹'] = top10_cost['æˆæœ¬æ¯”ä¾‹'] + top10_cost['æ¯›åˆ©æ¯”ä¾‹']
                                
                                # Only display verification data if debug is on
                                if show_debug:
                                    st.write("æˆæœ¬çµæ§‹é©—è­‰:")
                                    verification_df = top10_cost[['ç”¢å“åç¨±', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©', 'æˆæœ¬æ¯”ä¾‹', 'æ¯›åˆ©æ¯”ä¾‹', 'ç¸½æ¯”ä¾‹']]
                                    st.dataframe(verification_df)
                                
                                # Create a stacked bar chart
                                import plotly.graph_objects as go
                                
                                fig = go.Figure()
                                
                                # Add cost bar
                                fig.add_trace(go.Bar(
                                    name='æˆæœ¬',
                                    x=top10_cost['ç”¢å“åç¨±'],
                                    y=top10_cost['ç²¾æº–æˆæœ¬'],
                                    marker_color='#EF5350',
                                    hovertemplate='æˆæœ¬: $%{y:,.0f}<br>ä½”æ¯”: %{text:.1f}%<extra></extra>',
                                    text=top10_cost['æˆæœ¬æ¯”ä¾‹']
                                ))
                                
                                # Add profit bar
                                fig.add_trace(go.Bar(
                                    name='æ¯›åˆ©',
                                    x=top10_cost['ç”¢å“åç¨±'],
                                    y=top10_cost['ç²¾æº–æ¯›åˆ©'],
                                    marker_color='#66BB6A',
                                    hovertemplate='æ¯›åˆ©: $%{y:,.0f}<br>ä½”æ¯”: %{text:.1f}%<extra></extra>',
                                    text=top10_cost['æ¯›åˆ©æ¯”ä¾‹']
                                ))
                                
                                # Update layout for stacked bars
                                fig.update_layout(
                                    barmode='stack',
                                    title='å‰10å¤§ç”¢å“æˆæœ¬èˆ‡æ¯›åˆ©çµæ§‹',
                                    xaxis_title='ç”¢å“åç¨±',
                                    yaxis_title='é‡‘é¡',
                                    yaxis=dict(tickprefix='$'),
                                    legend=dict(
                                        orientation="h",
                                        yanchor="bottom",
                                        y=1.02,
                                        xanchor="right",
                                        x=1
                                    )
                                )
                                
                                # Display the chart
                                st.plotly_chart(fig, use_container_width=True)
                                
                                st.markdown("""
                                **åˆ†æèªªæ˜ï¼š**
                                - æ­¤åœ–è¡¨é¡¯ç¤ºæ¯å€‹ç”¢å“çš„æˆæœ¬ï¼ˆç´…è‰²ï¼‰å’Œæ¯›åˆ©ï¼ˆç¶ è‰²ï¼‰çµ„æˆ
                                - é€šéæ¯”è¼ƒä¸åŒç”¢å“çš„æˆæœ¬çµæ§‹ï¼Œå¯ä»¥ç™¼ç¾å“ªäº›ç”¢å“æœ‰è¼ƒé«˜çš„æˆæœ¬æ•ˆç‡
                                - ç†æƒ³æƒ…æ³ä¸‹ï¼Œç¶ è‰²éƒ¨åˆ†ï¼ˆæ¯›åˆ©ï¼‰æ‡‰ä½”è¼ƒå¤§æ¯”ä¾‹
                                """)
                        else:
                            st.warning("ç„¡ç”¢å“æ•¸æ“šå¯ç”¨æ–¼åˆ†æã€‚è«‹ç¢ºä¿ä¸Šå‚³çš„éŠ·è²¨æª”æ¡ˆåŒ…å«ç”¢å“è³‡è¨Šã€‚")
                    
                    with product_tab3:
                        st.markdown("### ğŸ“‹ å®Œæ•´ç”¢å“åˆ—è¡¨")
                        # Display full product summary table
                        st.dataframe(summary_df, use_container_width=True)
                        
                        # Add a download button for the summary data
                        csv_summary = summary_df.to_csv(index=False).encode('utf-8-sig')
                        st.download_button("ğŸ’¾ ä¸‹è¼‰ç”¢å“å½™ç¸½ CSV", csv_summary, f"product_summary_{'_'.join(selected_months)}.csv", "text/csv")
                
                with order_tab:
                    st.subheader(f"ğŸ“‹ {'ã€'.join(selected_months)} è¨‚å–®æ‘˜è¦è¡¨")
                    order_summary = generate_order_summary(sales_df)
                    
                    if order_summary.empty:
                        st.warning("ç„¡æ³•ç”Ÿæˆè¨‚å–®æ‘˜è¦ï¼Œå¯èƒ½ç¼ºå°‘å¿…è¦çš„è¨‚å–®è³‡æ–™æ¬„ä½ã€‚")
                    else:
                        # Determine which column to use for total amount
                        total_column = None
                        for col in ['ç¸½è¨ˆé‡‘é¡', 'å¯¦æ”¶ç¸½é¡', 'æœªç¨…å°è¨ˆ', 'è¨‚å–®ç”¢å“ç¸½é¡']:
                            if col in order_summary.columns:
                                total_column = col
                                break
                        
                        # Create a visually appealing metrics section
                        st.markdown("### ğŸ“Š éŠ·å”®è¡¨ç¾æ‘˜è¦")
                        
                        # Calculate key metrics
                        total_orders = len(order_summary)
                        total_amount = order_summary[total_column].sum() if total_column else 0
                        avg_order = total_amount / total_orders if total_orders > 0 else 0
                        
                        # Create a stylish metrics section with custom styling
                        metrics_container = st.container()
                        with metrics_container:
                            # Use CSS to style the metrics cards
                            st.markdown("""
                            <style>
                            .metric-card {
                                background-color: #f8f9fa;
                                border-radius: 10px;
                                padding: 20px;
                                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                                text-align: center;
                                transition: transform 0.3s;
                            }
                            .metric-card:hover {
                                transform: translateY(-5px);
                            }
                            .metric-value {
                                font-size: 28px;
                                font-weight: bold;
                                color: #1E88E5;
                                margin: 10px 0;
                            }
                            .metric-title {
                                font-size: 16px;
                                color: #455A64;
                                margin-top: 5px;
                            }
                            </style>
                            """, unsafe_allow_html=True)
                            
                            # Create three metric cards in columns
                            col1, col2, col3 = st.columns(3)
                            
                            with col1:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">è¨‚å–®ç¸½æ•¸</div>
                                    <div class="metric-value">{total_orders:,}</div>
                                    <div class="metric-title">ç­†</div>
                                </div>
                                """, unsafe_allow_html=True)
                            
                            with col2:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">ç¸½éŠ·å”®é¡</div>
                                    <div class="metric-value">${total_amount:,.0f}</div>
                                    <div class="metric-title">æ–°å°å¹£</div>
                                </div>
                                """, unsafe_allow_html=True)
                            
                            with col3:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">å¹³å‡è¨‚å–®é‡‘é¡</div>
                                    <div class="metric-value">${avg_order:,.0f}</div>
                                    <div class="metric-title">æ–°å°å¹£/ç­†</div>
                                </div>
                                """, unsafe_allow_html=True)
                        
                        # Add spacing
                        st.markdown("<br>", unsafe_allow_html=True)
                        
                        # Generate and display top 10 customers
                        st.markdown("### ğŸ† å‰10å¤§å®¢æˆ¶")
                        
                        # Get customer summary
                        customer_summary = generate_customer_summary(order_summary)
                        
                        if not customer_summary.empty:
                            # Display top 10 customers
                            top_customers = customer_summary.head(10)
                            
                            # Create two columns for visualization and table
                            viz_col, table_col = st.columns([3, 2])
                            
                            with viz_col:
                                # Create a bar chart for top customers
                                data = {
                                    'customer': top_customers['å®¢æˆ¶åç¨±'].tolist(),
                                    'amount': top_customers['æ¶ˆè²»ç¸½é¡'].tolist(),
                                    'orders': top_customers['è¨‚å–®æ•¸é‡'].tolist()
                                }
                                
                                # Use Streamlit native charts instead of matplotlib to avoid font issues
                                import altair as alt
                                
                                # Prepare the data in the format Altair expects
                                chart_data = pd.DataFrame({
                                    'å®¢æˆ¶åç¨±': data['customer'],
                                    'æ¶ˆè²»ç¸½é¡': data['amount'],
                                    'è¨‚å–®æ•¸é‡': data['orders']
                                })
                                
                                # Create label with formatted amount and order count
                                chart_data['label'] = chart_data.apply(
                                    lambda x: f"${x['æ¶ˆè²»ç¸½é¡']:,.0f} ({x['è¨‚å–®æ•¸é‡']}ç­†)",
                                    axis=1
                                )
                                
                                # Create an Altair chart
                                chart = alt.Chart(chart_data).mark_bar().encode(
                                    y=alt.Y('å®¢æˆ¶åç¨±:N', sort='-x', title=None),
                                    x=alt.X('æ¶ˆè²»ç¸½é¡:Q', title='éŠ·å”®ç¸½é¡'),
                                    color=alt.value('#2196F3'),
                                    tooltip=['å®¢æˆ¶åç¨±', 'æ¶ˆè²»ç¸½é¡', 'è¨‚å–®æ•¸é‡', 'label']
                                ).properties(
                                    title='å‰10å¤§å®¢æˆ¶éŠ·å”®é¡',
                                    height=400
                                )
                                
                                # Add text labels
                                text = chart.mark_text(
                                    align='left',
                                    baseline='middle',
                                    dx=5,  # Offset the text slightly to the right of the bar
                                    color='black'
                                ).encode(
                                    text='label'
                                )
                                
                                # Combine chart and text
                                final_chart = (chart + text).configure_view(
                                    strokeWidth=0
                                ).configure_title(
                                    fontSize=16,
                                    font='Arial',
                                    anchor='start',
                                    fontWeight='bold'
                                ).configure_axis(
                                    labelFontSize=12,
                                    titleFontSize=14,
                                    grid=False
                                )
                                
                                # Display the chart
                                st.altair_chart(final_chart, use_container_width=True)
                            
                            with table_col:
                                # Format the table for display
                                display_df = top_customers.copy()
                                display_df['æ¶ˆè²»ç¸½é¡'] = display_df['æ¶ˆè²»ç¸½é¡'].apply(lambda x: f"${x:,.0f}")
                                display_df['å¹³å‡å–®ç­†é‡‘é¡'] = display_df['å¹³å‡å–®ç­†é‡‘é¡'].apply(lambda x: f"${x:,.0f}")
                                
                                # Display the table
                                st.dataframe(display_df, use_container_width=True)
                        
                        # Add spacing
                        st.markdown("<br>", unsafe_allow_html=True)
                        
                        # Display order summary table with a section header
                        st.markdown("### ğŸ“ è¨‚å–®è©³ç´°è³‡æ–™")
                        st.dataframe(order_summary, use_container_width=True)
                        
                        # Add a download button for the order summary data
                        csv_orders = order_summary.to_csv(index=False).encode('utf-8-sig')
                        st.download_button("ğŸ’¾ ä¸‹è¼‰è¨‚å–®æ‘˜è¦ CSV", csv_orders, f"order_summary_{'_'.join(selected_months)}.csv", "text/csv")
                
                with bc_tab:
                # Process BC data if available
                    has_bc_data = (data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ" and bc_file) or (data_source == "ä½¿ç”¨å·²ä¸Šå‚³çš„æª”æ¡ˆ" and bc_data_source)
                
                    if has_bc_data:
                      try:
                        # Load BC data based on the data source
                        if data_source == "ä¸Šå‚³æ–°æª”æ¡ˆ":
                            bc_df = pd.read_excel(bc_file)
                        else:  # Using previously uploaded files
                            bc_df = pd.read_excel(bc_data_source)
                        
                        merged_df = merge_with_bc(summary_df, bc_df)

                        # Create tabs within the BC tab for different analyses
                        bc_tab1, bc_tab2, bc_tab3, bc_tab4 = st.tabs(["äº¤å‰æ¯”å°çµæœ", "å» å•†éŠ·å”®å½™ç¸½", "ç†±éŠ·å“ç²¾æº–æ¯›åˆ©é«˜åˆ°ä½", "å» å•†ç”¢å“æŸ¥è©¢"])

                        with bc_tab1:
                            st.subheader("ğŸ”„ èˆ‡ BC è³‡æ–™äº¤å‰æ¯”å°çµæœ")
                            st.dataframe(merged_df, use_container_width=True)
                            
                            csv_merged = merged_df.to_csv(index=False).encode('utf-8-sig')
                            st.download_button("ä¸‹è¼‰äº¤å‰æ¯”å° CSV", csv_merged, f"merged_bc_sales_{'_'.join(selected_months)}.csv", "text/csv")
                        
                        with bc_tab2:
                            st.subheader("ğŸ“¦ å» å•†éŠ·å”®å½™ç¸½")
                            vendor_df = vendor_summary_table(merged_df)
                            st.dataframe(vendor_df, use_container_width=True)
                            
                            csv_vendor = vendor_df.to_csv(index=False).encode('utf-8-sig')
                            st.download_button("ä¸‹è¼‰å» å•†å½™ç¸½ CSV", csv_vendor, f"vendor_summary_{'_'.join(selected_months)}.csv", "text/csv")
                        
                        with bc_tab3:
                            st.subheader("ğŸ”¥ ç†±éŠ·å“ç²¾æº–æ¯›åˆ©é«˜åˆ°ä½")
                            
                            # Get the full product list from summary_df and sort by profit (high to low)
                            profit_sorted_df = summary_df.sort_values(by='ç²¾æº–æ¯›åˆ©', ascending=False).copy()
                            
                            # Match product codes with BC file to extract inventory data
                            try:
                                # Ensure we have the BC data
                                if 'æ•¸é‡' in bc_df.columns and 'ç”¢å“ä»£è™Ÿ' in bc_df.columns:
                                    # Create a dictionary mapping product codes to inventory quantities
                                    inventory_dict = dict(zip(bc_df['ç”¢å“ä»£è™Ÿ'], bc_df['æ•¸é‡']))
                                    
                                    # Add inventory column to the profit sorted table
                                    profit_sorted_df['åº«å­˜'] = profit_sorted_df['ç”¢å“ä»£è™Ÿ'].map(inventory_dict)
                                    
                                    # Clean inventory values - handle commas and convert to numeric
                                    # First convert to string to ensure we can handle all possible values
                                    profit_sorted_df['åº«å­˜'] = profit_sorted_df['åº«å­˜'].astype(str)
                                    # Remove commas from numbers
                                    profit_sorted_df['åº«å­˜'] = profit_sorted_df['åº«å­˜'].str.replace(',', '', regex=False)
                                    # Convert to numeric, coercing errors to NaN
                                    profit_sorted_df['åº«å­˜'] = pd.to_numeric(profit_sorted_df['åº«å­˜'], errors='coerce')
                                    # Fill NaN values with 0 for products not found in BC data
                                    profit_sorted_df['åº«å­˜'] = profit_sorted_df['åº«å­˜'].fillna(0).astype(int)
                                    
                                    # Calculate days of inventory based on sales data
                                    # Only calculate if both columns exist and are non-zero
                                    profit_sorted_df['éŠ·å”®/å¤©'] = profit_sorted_df['æ•¸é‡'] / 30  # Assuming monthly data (30 days)
                                    
                                    # Calculate days of inventory, handle divide by zero
                                    profit_sorted_df['åº«å­˜å¤©æ•¸'] = profit_sorted_df.apply(
                                        lambda x: round(x['åº«å­˜'] / x['éŠ·å”®/å¤©']) if x['éŠ·å”®/å¤©'] > 0 else 0,
                                        axis=1
                                    )
                                    
                                    # Create color indicator for inventory status
                                    def inventory_status(days):
                                        if days <= 0:
                                            return "ç¼ºè²¨"
                                        elif days < 30:
                                            return "ä½"
                                        elif days < 90:
                                            return "é©ä¸­"
                                        else:
                                            return "éå¤š"
                                    
                                    profit_sorted_df['åº«å­˜ç‹€æ…‹'] = profit_sorted_df['åº«å­˜å¤©æ•¸'].apply(inventory_status)
                                else:
                                    st.warning("BCæª”æ¡ˆä¸­ç¼ºå°‘å¿…è¦çš„'ç”¢å“ä»£è™Ÿ'æˆ–'æ•¸é‡'æ¬„ä½ï¼Œç„¡æ³•é¡¯ç¤ºåº«å­˜è³‡è¨Š")
                            except Exception as e:
                                st.error(f"è™•ç†åº«å­˜è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
                                # Continue without inventory data
                                if 'åº«å­˜' not in profit_sorted_df.columns:
                                    profit_sorted_df['åº«å­˜'] = 0
                            
                            # Add explanation of inventory status calculation
                            st.markdown("""
### åº«å­˜ç‹€æ³èªªæ˜ï¼š
- **åº«å­˜å¤©æ•¸** = ç›®å‰åº«å­˜æ•¸é‡ Ã· æ¯æ—¥å¹³å‡éŠ·å”®é‡ï¼ˆæœˆéŠ·é‡Ã·30å¤©ï¼‰
- **åº«å­˜ç‹€æ…‹**ï¼š
  - **ç¼ºè²¨**ï¼šåº«å­˜ç‚ºé›¶
  - **ä½**ï¼šåº«å­˜å¤©æ•¸ < 30å¤©ï¼ˆå°‘æ–¼ä¸€å€‹æœˆï¼‰
  - **é©ä¸­**ï¼šåº«å­˜å¤©æ•¸ 30-90å¤©ï¼ˆ1-3å€‹æœˆï¼‰
  - **éå¤š**ï¼šåº«å­˜å¤©æ•¸ > 90å¤©ï¼ˆè¶…éä¸‰å€‹æœˆï¼‰
""")
                            
                            # Create a styled table
                            st.markdown("ä»¥ä¸‹æ˜¯ä¾ç…§ç²¾æº–æ¯›åˆ©å¾é«˜åˆ°ä½æ’åºçš„æ‰€æœ‰ç”¢å“åˆ—è¡¨ï¼š")
                            
                            # Add rank column for better readability if not already present
                            if 'æ’å' not in profit_sorted_df.columns:
                                profit_sorted_df.insert(0, 'æ’å', range(1, len(profit_sorted_df) + 1))
                            
                            # Reorder columns to show inventory status right after product code
                            desired_columns = ['æ’å', 'ç”¢å“ä»£è™Ÿ']
                            
                            # Add inventory columns if they exist
                            inventory_columns = ['åº«å­˜', 'åº«å­˜å¤©æ•¸', 'åº«å­˜ç‹€æ…‹']
                            for col in inventory_columns:
                                if col in profit_sorted_df.columns:
                                    desired_columns.append(col)
                            
                            # Add remaining columns
                            remaining_columns = [col for col in profit_sorted_df.columns 
                                              if col not in desired_columns + ['éŠ·å”®/å¤©']]
                            
                            # Combine all columns in desired order
                            final_columns = desired_columns + remaining_columns
                            
                            # Display the table with the selected columns
                            st.dataframe(profit_sorted_df[final_columns], use_container_width=True)
                            
                            # Add a download button for this sorted list
                            csv_profit_sorted = profit_sorted_df[final_columns].to_csv(index=False).encode('utf-8-sig')
                            st.download_button("ä¸‹è¼‰ç²¾æº–æ¯›åˆ©æ’åº CSV", csv_profit_sorted, f"profit_sorted_products_{'_'.join(selected_months)}.csv", "text/csv")
                            
                        with bc_tab4:
                            st.subheader("ğŸ­ å» å•†ç”¢å“æŸ¥è©¢")
                            
                            # Initialize session state for vendor selection if not already done
                            if 'selected_vendor' not in st.session_state:
                                st.session_state.selected_vendor = "è«‹é¸æ“‡..."
                            
                            # First, check if BC file has vendor information
                            if 'bc_df' in locals() and 'å» å•†ç°¡ç¨±' in bc_df.columns:
                                # Get unique vendor names and sort them alphabetically
                                vendors = sorted(bc_df['å» å•†ç°¡ç¨±'].dropna().unique().tolist())
                                
                                if vendors:
                                    # Create a dropdown for vendor selection with callback
                                    def on_vendor_change():
                                        # This is called when the selection changes
                                        pass
                                    
                                    # Use key parameter to maintain selection state
                                    selected_vendor = st.selectbox(
                                        "é¸æ“‡å» å•†æŸ¥çœ‹å…¶æ‰€æœ‰ç”¢å“:",
                                        ["è«‹é¸æ“‡..."] + vendors,
                                        key="vendor_selector"
                                    )
                                    
                                    # Store selection in session state for persistence
                                    st.session_state.selected_vendor = selected_vendor
                                    
                                    if selected_vendor != "è«‹é¸æ“‡...":
                                        # Filter BC data to show only the selected vendor's products
                                        vendor_products = bc_df[bc_df['å» å•†ç°¡ç¨±'] == selected_vendor].copy()
                                        
                                        if not vendor_products.empty:
                                            st.success(f"å·²æ‰¾åˆ° {len(vendor_products)} é … {selected_vendor} çš„ç”¢å“")
                                            
                                            # Create tabs for different views of vendor products
                                            vendor_tab1, vendor_tab2 = st.tabs(["åº«å­˜è³‡è¨Š", "éŠ·å”®è³‡è¨Š"])
                                            
                                            with vendor_tab1:
                                                # Sort by product code for easier lookup
                                                vendor_products_sorted = vendor_products.sort_values('ç”¢å“ä»£è™Ÿ')
                                                
                                                # Select relevant columns for display
                                                display_columns = ['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'å–®ä½', 'æ•¸é‡']
                                                display_columns = [col for col in display_columns if col in vendor_products_sorted.columns]
                                                
                                                # Add any other available inventory-related columns
                                                for col in vendor_products_sorted.columns:
                                                    if 'æˆæœ¬' in col or 'å”®åƒ¹' in col or 'åº«å­˜' in col:
                                                        if col not in display_columns:
                                                            display_columns.append(col)
                                                
                                                # Display the inventory information
                                                st.dataframe(vendor_products_sorted[display_columns], use_container_width=True)
                                                
                                                # Add download button for the vendor's product data
                                                csv_vendor_products = vendor_products_sorted[display_columns].to_csv(index=False).encode('utf-8-sig')
                                                st.download_button(
                                                    f"ä¸‹è¼‰ {selected_vendor} åº«å­˜è³‡è¨Š",
                                                    csv_vendor_products,
                                                    f"{selected_vendor}_inventory.csv",
                                                    "text/csv"
                                                )
                                            
                                            with vendor_tab2:
                                                # Cross-reference with sales data for this vendor's products
                                                if 'merged_df' in locals():
                                                    vendor_sales = merged_df[merged_df['å» å•†ç°¡ç¨±'] == selected_vendor].copy()
                                                    
                                                    if not vendor_sales.empty:
                                                        # Sort by sales amount (high to low)
                                                        vendor_sales_sorted = vendor_sales.sort_values('å°è¨ˆ', ascending=False)
                                                        
                                                        # Select relevant columns for sales view
                                                        sales_columns = ['ç”¢å“ä»£è™Ÿ', 'ç”¢å“åç¨±', 'åº«å­˜æ•¸é‡', 'éŠ·å”®æ•¸é‡', 'å°è¨ˆ', 'ç²¾æº–æˆæœ¬', 'ç²¾æº–æ¯›åˆ©']
                                                        sales_columns = [col for col in sales_columns if col in vendor_sales_sorted.columns]
                                                        
                                                        # Display the table
                                                        st.dataframe(vendor_sales_sorted[sales_columns], use_container_width=True)
                                                        
                                                        # Calculate total sales and profit for this vendor
                                                        total_sales = vendor_sales_sorted['å°è¨ˆ'].sum() if 'å°è¨ˆ' in vendor_sales_sorted.columns else 0
                                                        total_profit = vendor_sales_sorted['ç²¾æº–æ¯›åˆ©'].sum() if 'ç²¾æº–æ¯›åˆ©' in vendor_sales_sorted.columns else 0
                                                        
                                                        # Display summary metrics
                                                        col1, col2, col3 = st.columns(3)
                                                        with col1:
                                                            st.metric("ç”¢å“æ•¸é‡", f"{len(vendor_sales_sorted)}")
                                                        with col2:
                                                            st.metric("ç¸½éŠ·å”®é¡", f"${total_sales:,.0f}")
                                                        with col3:
                                                            st.metric("ç¸½æ¯›åˆ©", f"${total_profit:,.0f}")
                                                        
                                                        # Add download button for the sales data
                                                        csv_vendor_sales = vendor_sales_sorted[sales_columns].to_csv(index=False).encode('utf-8-sig')
                                                        st.download_button(
                                                            f"ä¸‹è¼‰ {selected_vendor} éŠ·å”®è³‡è¨Š",
                                                            csv_vendor_sales,
                                                            f"{selected_vendor}_sales.csv",
                                                            "text/csv"
                                                        )
                                                    else:
                                                        st.info(f"æ²’æœ‰ {selected_vendor} çš„éŠ·å”®æ•¸æ“š")
                                                else:
                                                    st.info("æ²’æœ‰å¯ç”¨çš„éŠ·å”®æ•¸æ“šã€‚è«‹ç¢ºä¿å·²ç¶“ç”Ÿæˆäº¤å‰æ¯”å°çµæœã€‚")
                                        else:
                                            st.warning("BCæª”æ¡ˆä¸­æ²’æœ‰æ‰¾åˆ°å» å•†è³‡è¨Š")
                                    else:
                                        st.info("è«‹é¸æ“‡å» å•†æŸ¥çœ‹å…¶æ‰€æœ‰ç”¢å“...")
                                else:
                                    st.warning("BCæª”æ¡ˆä¸­æ²’æœ‰æ‰¾åˆ°å» å•†è³‡è¨Š")
                            else:
                                st.warning("BCæª”æ¡ˆä¸­ç¼ºå°‘'å» å•†ç°¡ç¨±'æ¬„ä½ï¼Œç„¡æ³•é€²è¡Œå» å•†ç”¢å“æŸ¥è©¢")
                      except Exception as e:
                          st.error(f"è™•ç† BC è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
                    else:
                        st.info("è«‹ä¸Šå‚³ BC è³‡æ–™ä»¥æŸ¥çœ‹äº¤å‰æ¯”å°çµæœ")
            except Exception as e:
                st.error(f"ç”Ÿæˆå ±è¡¨æ™‚ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {e}")
else:
    st.info("è«‹å…ˆé¸æ“‡æ•¸æ“šä¾†æºï¼Œé¸æ“‡æœˆä»½å¾ŒæŒ‰ä¸‹ã€ç”Ÿæˆå ±è¡¨ã€")

# Add file management and field overview sections at the bottom in a 2-column layout
st.markdown("---")
st.subheader("ç³»çµ±è¨­å®šèˆ‡ç®¡ç†")

# Create two columns for the bottom sections
file_mgmt_col, fields_overview_col = st.columns(2)

# FILE MANAGEMENT SECTION
with file_mgmt_col:
    st.markdown("### ğŸ“ æª”æ¡ˆç®¡ç†")
    
    # Initialize session state for file deletion confirmation
    if 'file_to_delete' not in st.session_state:
        st.session_state.file_to_delete = None
    if 'delete_type' not in st.session_state:
        st.session_state.delete_type = None
    
    file_mgmt_tab1, file_mgmt_tab2 = st.tabs(["éŠ·è²¨æª”æ¡ˆ", "BC æª”æ¡ˆ"])
    
    with file_mgmt_tab1:
        sales_files_list = get_file_list(SALES_DIR, ".xlsx")
        
        # Add a button to refresh the file list
        if st.button("ğŸ”„ é‡æ–°æ•´ç†éŠ·è²¨æª”æ¡ˆåˆ—è¡¨"):
            st.rerun()
        
        if not sales_files_list:
            st.info("å°šæœªä¸Šå‚³ä»»ä½•éŠ·è²¨æª”æ¡ˆ")
        else:
            st.write(f"å·²ä¸Šå‚³çš„éŠ·è²¨æª”æ¡ˆ ({len(sales_files_list)})")
            
            # Create columns for each file with delete buttons
            for i, file in enumerate(sales_files_list):
                col1, col2, col3 = st.columns([6, 3, 1])
                with col1:
                    st.text(f"{i+1}. {file['name']}")
                with col2:
                    st.text(f"ä¿®æ”¹: {file['mod_time_str']}")
                with col3:
                    # Use unique key for each button
                    if st.button("ğŸ—‘ï¸", key=f"delete_sales_{i}", help="åˆªé™¤æ­¤æª”æ¡ˆ"):
                        st.session_state.file_to_delete = file['path']
                        st.session_state.delete_type = "sales"
                        st.rerun()
            
            # Add a button to delete all sales files
            if st.button("ğŸ—‘ï¸ åˆªé™¤æ‰€æœ‰éŠ·è²¨æª”æ¡ˆ", type="secondary"):
                st.session_state.file_to_delete = "ALL_SALES"
                st.session_state.delete_type = "all_sales"
                st.rerun()
    
    with file_mgmt_tab2:
        bc_files_list = get_file_list(BC_DIR, ".xlsx")
        
        # Add a button to refresh the file list
        if st.button("ğŸ”„ é‡æ–°æ•´ç†BCæª”æ¡ˆåˆ—è¡¨"):
            st.rerun()
        
        if not bc_files_list:
            st.info("å°šæœªä¸Šå‚³ä»»ä½• BC æª”æ¡ˆ")
        else:
            st.write(f"å·²ä¸Šå‚³çš„ BC æª”æ¡ˆ ({len(bc_files_list)})")
            
            # Create columns for each file with delete buttons
            for i, file in enumerate(bc_files_list):
                col1, col2, col3 = st.columns([6, 3, 1])
                with col1:
                    st.text(f"{i+1}. {file['name']}")
                with col2:
                    st.text(f"ä¿®æ”¹: {file['mod_time_str']}")
                with col3:
                    # Use unique key for each button
                    if st.button("ğŸ—‘ï¸", key=f"delete_bc_{i}", help="åˆªé™¤æ­¤æª”æ¡ˆ"):
                        st.session_state.file_to_delete = file['path']
                        st.session_state.delete_type = "bc"
                        st.rerun()
            
            # Add a button to delete all BC files
            if st.button("ğŸ—‘ï¸ åˆªé™¤æ‰€æœ‰BCæª”æ¡ˆ", type="secondary"):
                st.session_state.file_to_delete = "ALL_BC"
                st.session_state.delete_type = "all_bc"
                st.rerun()

# FIELD OVERVIEW SECTION
with fields_overview_col:
    # Create a collapsible section for field overview
    with st.expander("ğŸ“ å¿…è¦æ¬„ä½ä¸€è¦½", expanded=False):
        st.markdown("ä¸Šå‚³æª”æ¡ˆéœ€åŒ…å«ä¸‹åˆ—æ¬„ä½ï¼Œå¦å‰‡å¯èƒ½å°è‡´åˆ†æå¤±æ•—ï¼š")
        
        # Create tabs for different header categories
        header_tabs = st.tabs(list(header_categories.keys()))
        
        for i, (category, headers) in enumerate(header_categories.items()):
            with header_tabs[i]:
                # Show headers in this category
                category_headers = [h for h in headers if h in required_headers]
                if category_headers:
                    headers_df = pd.DataFrame({"æ¬„ä½åç¨±": category_headers})
                    st.dataframe(headers_df, use_container_width=True)
                else:
                    st.info(f"æ­¤é¡åˆ¥ä¸­æ²’æœ‰å¿…è¦çš„æ¬„ä½")
        
        # Add sample file download section
        st.markdown("### ç¯„ä¾‹æª”æ¡ˆ")
        
        # Provide sample file downloads
        col1, col2 = st.columns(2)
        with col1:
            csv_sample = sample_df.to_csv(index=False).encode('utf-8-sig')
            st.download_button("â¬‡ï¸ ä¸‹è¼‰ç¯„ä¾‹æª”æ¡ˆCSV", csv_sample, "sales_sample.csv", "text/csv")
        
        with col2:
            excel_sample = BytesIO()
            sample_df.to_excel(excel_sample, index=False, engine='openpyxl')
            excel_sample.seek(0)
            st.download_button("â¬‡ï¸ ä¸‹è¼‰ç¯„ä¾‹æª”æ¡ˆExcel", excel_sample, "sales_sample.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        
        # Add tips for file preparation
        st.info("""
        ğŸ’¡ **æç¤º:** 
        - æœ‰äº›æ¬„ä½å¯ä»¥ç‚ºç©ºï¼Œä½†é—œéµæ¬„ä½å¦‚ã€Œç”¢å“ä»£è™Ÿã€ã€ã€Œæ•¸é‡ã€ã€ã€Œå°è¨ˆã€å¿…é ˆæœ‰å€¼
        - å°æ–¼ç›¸åŒè¨‚å–®çš„å¤šå€‹ç”¢å“é …ç›®ï¼Œè¨‚å–®è³‡è¨Šæœƒåœ¨ç¬¬ä¸€åˆ—å¡«å¯«ï¼Œå¾ŒçºŒç”¢å“é …ç›®å¯ä»¥ç•™ç©º
        - æ­¤é¡åˆ¥èˆ‡æ¬„ä½å¯ç‚ºç©ºï¼Œä½†è«‹ç¢ºä¿å¿…å¡«æ¬„ä½æœ‰å€¼
        """)

# Handle file deletion with confirmation (outside the columns to ensure proper layout)
if st.session_state.file_to_delete:
    with st.form(key="delete_confirmation"):
        if st.session_state.delete_type == "sales":
            file_name = os.path.basename(st.session_state.file_to_delete)
            st.warning(f"ç¢ºå®šè¦åˆªé™¤éŠ·è²¨æª”æ¡ˆ '{file_name}' å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ¢å¾©ã€‚")
        elif st.session_state.delete_type == "bc":
            file_name = os.path.basename(st.session_state.file_to_delete)
            st.warning(f"ç¢ºå®šè¦åˆªé™¤BCæª”æ¡ˆ '{file_name}' å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ¢å¾©ã€‚")
        elif st.session_state.delete_type == "all_sales":
            st.warning(f"ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰ {len(sales_files_list)} å€‹éŠ·è²¨æª”æ¡ˆå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ¢å¾©ã€‚")
        elif st.session_state.delete_type == "all_bc":
            st.warning(f"ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰ {len(bc_files_list)} å€‹BCæª”æ¡ˆå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ¢å¾©ã€‚")
        
        col1, col2 = st.columns([1, 1])
        with col1:
            confirm_delete = st.form_submit_button("âš ï¸ ç¢ºèªåˆªé™¤")
        with col2:
            cancel_delete = st.form_submit_button("å–æ¶ˆ")
        
        if confirm_delete:
            if st.session_state.delete_type in ["sales", "bc"]:
                # Delete single file
                if delete_file(st.session_state.file_to_delete):
                    st.success(f"å·²æˆåŠŸåˆªé™¤æª”æ¡ˆ '{os.path.basename(st.session_state.file_to_delete)}'")
            elif st.session_state.delete_type == "all_sales":
                # Delete all sales files
                deleted_count = 0
                for file in sales_files_list:
                    if delete_file(file['path']):
                        deleted_count += 1
                st.success(f"å·²æˆåŠŸåˆªé™¤ {deleted_count} å€‹éŠ·è²¨æª”æ¡ˆ")
            elif st.session_state.delete_type == "all_bc":
                # Delete all BC files
                deleted_count = 0
                for file in bc_files_list:
                    if delete_file(file['path']):
                        deleted_count += 1
                st.success(f"å·²æˆåŠŸåˆªé™¤ {deleted_count} å€‹BCæª”æ¡ˆ")
            
            # Reset the session state
            st.session_state.file_to_delete = None
            st.session_state.delete_type = None
            st.rerun()
        
        if cancel_delete:
            # Reset the session state
            st.session_state.file_to_delete = None
            st.session_state.delete_type = None
            st.rerun()
