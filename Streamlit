# Version 1.1: Added Daily Sales Chart
import streamlit as st
import pandas as pd
import os
import base64
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
import numpy as np

# --------------------------------------------------
# 🔧 CONFIG & CONSTANTS ---------------------------
# --------------------------------------------------
st.set_page_config(page_title="數據圖表生成器", layout="wide")

UPLOADED_SALES_DIR = "uploaded_data/sales_files"
UPLOADED_BC_DIR = "uploaded_data/bc_files"
os.makedirs(UPLOADED_SALES_DIR, exist_ok=True)
os.makedirs(UPLOADED_BC_DIR, exist_ok=True)

# Data structure definitions
ORDER_LEVEL_COLUMNS = [
    "銷貨單號", "訂單單號", "銷貨日期", "客戶代號", "客戶名稱", "部門代號", "部門名稱", 
    "發票號碼", "未稅小計", "營業稅", "折讓金額", "稅前折價", "總計金額", "實收總額", 
    "成本總額", "毛利", "毛利率"
]

PRODUCT_LEVEL_COLUMNS = [
    "產品代號", "產品名稱", "倉別代號", "倉別名稱", "數量", "單位", "單價", "小計", 
    "成本總值", "產品毛利", "產品毛利率", "銷售單價1", "精準成本", "精準毛利", 
    "單位管銷成本", "管銷成本合計", "*銷貨日期", "*客戶代號", "*客戶條件", 
    "*部門代號", "*業務代號", "*業務條件"
]

BC_COLUMNS = [
    "產品代號", "產品名稱", "數量", "倉庫", "單位", "成本單價", "成本總價", 
    "安全存量", "廠商代號", "廠商簡稱", "最後出貨日", "最後進貨日", "銷售單價1", 
    "銷售單價2", "銷售單價3", "銷售單價4", "最低售價", "數量為零自動下架", 
    "持續上架", "停止上架", "大類名稱", "中類名稱", "小類名稱", "備註", 
    "EAN13碼", "CO128碼", "建議售價", "毛利率"
]

# Column definitions with explanations
COLUMN_DEFINITIONS = {
    # Order level
    "銷貨單號": "訂單的唯一識別碼",
    "訂單單號": "客戶的訂單編號",
    "銷貨日期": "商品銷售的日期",
    "客戶代號": "客戶的編號代碼",
    "客戶名稱": "客戶的全名",
    "部門代號": "部門的編號代碼",
    "部門名稱": "部門的全名",
    "發票號碼": "發票的識別號碼",
    "未稅小計": "未包含稅金的總金額",
    "營業稅": "交易中的稅金金額",
    "折讓金額": "折扣或退款的金額",
    "稅前折價": "稅前的折扣金額",
    "總計金額": "包含稅金的總金額",
    "實收總額": "實際收到的總金額",
    "成本總額": "所有產品的總成本",
    "毛利": "總計金額減去成本總額的差值",
    "毛利率": "毛利除以總計金額的百分比",
    
    # Product level
    "產品代號": "產品的唯一識別碼",
    "產品名稱": "產品的名稱",
    "倉別代號": "倉庫的編號代碼",
    "倉別名稱": "倉庫的名稱",
    "數量": "銷售的產品數量",
    "單位": "產品的計量單位",
    "單價": "每單位產品的價格",
    "小計": "單價乘以數量的金額",
    "成本總值": "產品的總成本",
    "產品毛利": "小計減去成本總值的差額",
    "產品毛利率": "產品毛利除以小計的百分比",
    "銷售單價1": "產品的銷售單價",
    "精準成本": "計算後的精確成本",
    "精準毛利": "計算後的精確毛利",
    "單位管銷成本": "每單位產品的管理和銷售成本",
    "管銷成本合計": "總管理和銷售成本",
    "*銷貨日期": "產品層級的銷貨日期",
    "*客戶代號": "產品層級的客戶代號",
    "*客戶條件": "與客戶相關的特殊條件",
    "*部門代號": "產品層級的部門代號",
    "*業務代號": "負責銷售的業務代表編號",
    "*業務條件": "與業務代表相關的特殊條件",
    
    # BC specific
    "倉庫": "產品儲存的倉庫",
    "成本單價": "每單位產品的成本",
    "成本總價": "成本單價乘以數量的總金額",
    "安全存量": "庫存應保持的最低數量",
    "廠商代號": "供應商的編號代碼",
    "廠商簡稱": "供應商的簡稱",
    "最後出貨日": "最近一次出貨的日期",
    "最後進貨日": "最近一次進貨的日期",
    "銷售單價2": "第二種銷售單價",
    "銷售單價3": "第三種銷售單價",
    "銷售單價4": "第四種銷售單價",
    "最低售價": "產品的最低銷售價格",
    "數量為零自動下架": "庫存為零時是否自動下架",
    "持續上架": "產品是否持續上架銷售",
    "停止上架": "產品是否停止上架銷售",
    "大類名稱": "產品的主要分類",
    "中類名稱": "產品的次要分類",
    "小類名稱": "產品的細分類別",
    "備註": "關於產品的附加說明",
    "EAN13碼": "產品的EAN13碼條碼",
    "CO128碼": "產品的Code 128條碼",
    "建議售價": "建議的零售價格",
    "毛利率": "毛利除以銷售價格的百分比"
}

# Initialize session state
if 'sales_files_uploaded' not in st.session_state:
    st.session_state.sales_files_uploaded = False
if 'bc_file_uploaded' not in st.session_state:
    st.session_state.bc_file_uploaded = False
if 'sales_data' not in st.session_state:
    st.session_state.sales_data = None
if 'bc_data' not in st.session_state:
    st.session_state.bc_data = None
if 'debug_info' not in st.session_state:
    st.session_state.debug_info = []
if 'processed_data' not in st.session_state:
    st.session_state.processed_data = {
        'order_level': None,
        'product_level': None,
        'monthly_summary': None
    }

# --------------------------------------------------
# 🛠️ UTILITY FUNCTIONS ----------------------------
# --------------------------------------------------

def get_uploaded_files(directory):
    """Lists files in the specified directory."""
    if not os.path.exists(directory):
        return []
    return [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]

def save_uploaded_file(uploaded_file, directory):
    """Saves an uploaded file to the specified directory."""
    if uploaded_file is not None:
        file_path = os.path.join(directory, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        return file_path
    return None

def load_excel(file_source, is_path=False):
    """Generic Excel loader."""
    try:
        if is_path:
            return pd.read_excel(file_source)
        else:
            return pd.read_excel(file_source)
    except Exception as e:
        display_name = "[Unknown Source]"
        if isinstance(file_source, str):
            display_name = os.path.basename(file_source)
        elif hasattr(file_source, 'name'):
            display_name = file_source.name
        st.session_state.debug_info.append(f"讀取檔案 '{display_name}' 時發生錯誤: {e}")
        return pd.DataFrame()

def debug_file_headers(df, file_type):
    """Debug file headers and check if the required columns exist."""
    if df is None or df.empty:
        return f"⚠️ {file_type}檔案為空或無法讀取"
    
    # Define required columns based on file type
    required_cols = []
    if file_type == "銷售":
        # Check for order level columns as minimum requirement
        required_cols = ORDER_LEVEL_COLUMNS
    elif file_type == "BC":
        # Check for basic BC columns
        required_cols = ["產品代號", "產品名稱", "數量", "倉庫", "單位", "成本單價", "成本總價"]
    
    # Check columns
    columns = df.columns.tolist()
    st.session_state.debug_info.append(f"{file_type}檔案欄位: {', '.join(columns[:10])}...")
    
    missing_cols = [col for col in required_cols if col not in columns]
    
    if missing_cols:
        return f"⚠️ {file_type}檔案缺少必要欄位: {', '.join(missing_cols)}"
    else:
        # If this is a sales file, also debug the hierarchical structure
        if file_type == "銷售":
            debug_hierarchical_structure(df)
        return f"✅ {file_type}檔案欄位正確"

def debug_hierarchical_structure(df):
    """Debug the hierarchical structure of the sales data with order-level and product-level rows."""
    if df is None or df.empty:
        st.session_state.debug_info.append("無法檢查分層結構: 數據為空")
        return
    
    try:
        # Check for a key order column that should be present for order rows
        key_order_col = '銷貨單號'
        
        if key_order_col not in df.columns:
            st.session_state.debug_info.append(f"無法檢查分層結構: 找不到關鍵欄位 '{key_order_col}'")
            return
        
        # Identify order rows (where key column is not null) and product rows (where key column is null)
        order_mask = df[key_order_col].notna()
        
        # Count order and product rows
        order_count = order_mask.sum()
        product_count = len(df) - order_count
        
        st.session_state.debug_info.append(f"檔案分層結構: {order_count} 筆訂單行, {product_count} 筆產品行")
        
        # Check the pattern of order and product rows
        # The expectation is: order row, followed by 0+ product rows, then the next order row
        sequential_errors = 0
        prev_is_order = None
        consecutive_orders = 0
        consecutive_products = 0
        
        for i, is_order in enumerate(order_mask):
            if prev_is_order is not None:
                if prev_is_order and is_order:
                    # Two consecutive order rows - could be legitimate but log for awareness
                    consecutive_orders += 1
                elif not prev_is_order and not is_order:
                    # Multiple consecutive product rows - normal
                    consecutive_products += 1
            
            prev_is_order = is_order
        
        if consecutive_orders > 0:
            st.session_state.debug_info.append(f"注意: 檢測到 {consecutive_orders} 次連續的訂單行，請確認數據結構正確")
        
        # Sample some order rows
        if order_count > 0:
            sample_order_indices = df[order_mask].head(2).index.tolist()
            for idx in sample_order_indices:
                sample_row = df.loc[idx]
                st.session_state.debug_info.append(f"訂單行樣本 (索引 {idx}):")
                # Show a few key columns from the order row
                for col in ['銷貨單號', '訂單單號', '銷貨日期', '客戶名稱'][:3]:
                    if col in sample_row:
                        st.session_state.debug_info.append(f"  {col}: {sample_row[col]}")
        
        # Sample some product rows
        if product_count > 0:
            sample_product_indices = df[~order_mask].head(2).index.tolist()
            for idx in sample_product_indices:
                sample_row = df.loc[idx]
                st.session_state.debug_info.append(f"產品行樣本 (索引 {idx}):")
                # Show a few key columns from the product row
                for col in ['產品代號', '產品名稱', '數量', '單價'][:3]:
                    if col in sample_row:
                        st.session_state.debug_info.append(f"  {col}: {sample_row[col]}")
    
    except Exception as e:
        st.session_state.debug_info.append(f"檢查分層結構時發生錯誤: {e}")

def identify_order_rows(df):
    """
    Identify rows that represent order headers in the hierarchical data structure.
    
    In the Excel sheet, order rows are those where all order-level columns are populated,
    while product rows have empty cells in order-level columns.
    """
    if df is None or df.empty:
        st.session_state.debug_info.append("無法識別訂單行: 數據為空")
        return None
    
    try:
        # Define a key order column that should always be populated for order rows
        # and null for product rows (e.g., '銷貨單號')
        key_order_col = '銷貨單號'
        
        if key_order_col not in df.columns:
            st.session_state.debug_info.append(f"識別訂單行失敗: 找不到關鍵欄位 '{key_order_col}'")
            return None
        
        # Create a mask where the key column is not null (identifying order rows)
        order_mask = df[key_order_col].notna()
        
        # Create a Series with row indices as values and their classification
        # True for order rows, False for product rows
        row_types = pd.Series(order_mask.values, index=df.index)
        
        st.session_state.debug_info.append(f"識別出 {row_types.sum()} 筆訂單行和 {len(row_types) - row_types.sum()} 筆產品行")
        
        return row_types
    
    except Exception as e:
        st.session_state.debug_info.append(f"識別訂單行時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def assign_order_to_products(df, row_types):
    """
    Assign each product row to its parent order by creating a mapping from product rows
    to their respective order rows based on the visual hierarchy in the Excel sheet.
    """
    if df is None or df.empty or row_types is None:
        st.session_state.debug_info.append("無法分配產品到訂單: 輸入數據無效")
        return None
    
    try:
        # Create a mapping dictionary {product_row_index: order_row_index}
        order_to_product_map = {}
        
        # Get indices of order rows
        order_indices = row_types[row_types].index.tolist()
        
        # For each order row, find all product rows that follow it until the next order row
        for i in range(len(order_indices)):
            current_order_idx = order_indices[i]
            
            # Determine the end boundary (next order row or end of dataframe)
            next_order_idx = order_indices[i + 1] if i < len(order_indices) - 1 else len(df)
            
            # All rows between current_order_idx and next_order_idx (exclusive) are product rows
            for product_idx in range(current_order_idx + 1, next_order_idx):
                # Check if this is indeed a product row (not an order row)
                if not row_types.get(product_idx, True):  # Default to True if key doesn't exist
                    order_to_product_map[product_idx] = current_order_idx
        
        # Verify the mapping
        product_count = len(order_to_product_map)
        expected_product_count = len(row_types) - len(order_indices)
        
        st.session_state.debug_info.append(f"已為 {product_count} 筆產品項目分配訂單")
        
        if product_count != expected_product_count:
            st.session_state.debug_info.append(f"警告: 產品分配數量({product_count})與預期數量({expected_product_count})不符")
        
        return order_to_product_map
    
    except Exception as e:
        st.session_state.debug_info.append(f"分配產品到訂單時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def split_data_levels(df):
    """
    Split the data into order level and product level information based on the hierarchical 
    structure in the Excel sheet, where order rows have all order-level columns populated
    and product rows have empty cells in order-level columns.
    """
    if df is None or df.empty:
        st.session_state.debug_info.append("無法分離訂單和產品層級: 數據為空")
        return None, None
    
    st.session_state.debug_info.append("正在分離訂單層級和產品層級數據...")
    
    try:
        # Check if required columns exist
        missing_order_cols = [col for col in ORDER_LEVEL_COLUMNS if col not in df.columns]
        missing_product_cols = [col for col in PRODUCT_LEVEL_COLUMNS if col not in df.columns]
        
        if missing_order_cols:
            st.session_state.debug_info.append(f"缺少訂單層級欄位: {missing_order_cols}")
        if missing_product_cols:
            st.session_state.debug_info.append(f"缺少產品層級欄位: {missing_product_cols}")
        
        # First check: Verify if the data already has a hierarchical structure identified
        # in the preprocessing step (preprocess_hierarchical_excel)
        
        # We need to re-check how to identify order rows vs product rows
        # Let's first look at the data structure
        if '銷貨單號' in df.columns:
            # Initial check for basic order row identification
            possible_order_mask = df['銷貨單號'].notna()
            order_count = possible_order_mask.sum()
            total_rows = len(df)
            
            if 0 < order_count < total_rows:
                # This looks like a proper hierarchical structure with both order and product rows
                st.session_state.debug_info.append(f"檢測到分層結構: {order_count} 筆訂單行 和 {total_rows - order_count} 筆產品行")
                row_types = possible_order_mask
            else:
                # If all rows have order numbers, we need a more sophisticated check
                st.session_state.debug_info.append(f"所有行都有訂單號，嘗試使用產品識別字段進行檢查")
                
                # Check if we have product-specific columns that can help identify product rows
                product_identifier_cols = ['產品代號', '產品名稱', '數量', '單價', '小計']
                has_product_cols = any(col in df.columns for col in product_identifier_cols)
                
                if has_product_cols:
                    # Use product columns to help identify product vs order rows
                    for col in product_identifier_cols:
                        if col in df.columns:
                            # Check if this column helps distinguish order vs product rows
                            values_present = df[col].notna()
                            present_count = values_present.sum()
                            
                            # If this column has values for a subset of rows, it might help identify product rows
                            if 0 < present_count < total_rows:
                                st.session_state.debug_info.append(f"使用產品欄位 '{col}' 識別產品行")
                                # Assume rows with product info are product rows, others are order rows
                                unique_invoice_count = df['銷貨單號'].nunique()
                                st.session_state.debug_info.append(f"數據中有 {unique_invoice_count} 個唯一訂單號")
                                
                                # If the count of unique invoice numbers is close to what we expect for order rows
                                if abs(unique_invoice_count - order_count) < 0.1 * total_rows:
                                    # Use this column to help identify product rows
                                    product_rows = values_present
                                    row_types = ~product_rows
                                    st.session_state.debug_info.append(f"根據 '{col}' 識別出 {row_types.sum()} 筆訂單行")
                                    break
                
                # If we still couldn't identify, fall back to unique invoice numbers
                if 'row_types' not in locals():
                    # Group by invoice number and only keep the first row of each group as an order row
                    unique_invoices = df.drop_duplicates(subset=['銷貨單號'])
                    row_types = df.index.isin(unique_invoices.index)
                    st.session_state.debug_info.append(f"使用唯一訂單號識別出 {row_types.sum()} 筆訂單行")
        else:
            st.session_state.debug_info.append("找不到訂單號欄位，無法識別訂單行")
            return None, None
        
        # Step 2: Create order level dataframe from identified order rows
        order_df = df[row_types].copy()
        
        # Ensure all required order columns are present
        order_cols = [col for col in ORDER_LEVEL_COLUMNS if col in df.columns]
        order_df = order_df[order_cols]
        
        # Step 3: Create product level dataframe from product rows
        product_df = df[~row_types].copy()
        
        # Ensure numeric columns are properly typed
        for col in ['總計金額', '毛利', '成本總額']:
            if col in order_df.columns and not pd.api.types.is_numeric_dtype(order_df[col]):
                order_df[col] = pd.to_numeric(order_df[col], errors='coerce')
        
        # Log the unique order count for verification
        if '銷貨單號' in order_df.columns:
            unique_orders = order_df['銷貨單號'].nunique()
            st.session_state.debug_info.append(f"訂單數據中有 {unique_orders} 個唯一訂單號")
            
            # Check if we have duplicated orders
            if unique_orders < len(order_df):
                st.session_state.debug_info.append(f"警告: 發現 {len(order_df) - unique_orders} 個重複訂單")
                
                # Keep only the first occurrence of each order
                order_df = order_df.drop_duplicates(subset=['銷貨單號'])
                st.session_state.debug_info.append(f"移除重複後有 {len(order_df)} 筆訂單")
        
        st.session_state.debug_info.append(f"成功建立訂單層級數據，共 {len(order_df)} 筆訂單")
        
        # Step 4: Assign each product to its parent order
        if not product_df.empty:
            # Create a mapping from order number to order row
            if '銷貨單號' in order_df.columns and '銷貨單號' in product_df.columns:
                # Some product rows might already have order number
                order_map = {}
                for idx, row in order_df.iterrows():
                    if pd.notna(row['銷貨單號']):
                        order_map[row['銷貨單號']] = idx
                
                # For products with missing order info, try to find their parent order
                for idx, row in product_df.iterrows():
                    if pd.isna(row['銷貨單號']) and idx > 0:
                        # Look for the closest preceding order row
                        preceding_orders = [o_idx for o_idx in order_df.index if o_idx < idx]
                        if preceding_orders:
                            closest_order_idx = max(preceding_orders)
                            if closest_order_idx in order_df.index:
                                product_df.at[idx, '銷貨單號'] = order_df.at[closest_order_idx, '銷貨單號']
            
            # Copy order information to product rows for key fields
            order_keys = ["銷貨日期", "客戶代號", "客戶名稱"]
            for key in order_keys:
                if key in order_df.columns and key in product_df.columns:
                    # Check if values are already present
                    missing_mask = product_df[key].isna()
                    if missing_mask.any() and '銷貨單號' in product_df.columns:
                        # For each product with missing value, look up from parent order
                        for idx in product_df[missing_mask].index:
                            order_num = product_df.at[idx, '銷貨單號']
                            if pd.notna(order_num) and order_num in order_df['銷貨單號'].values:
                                # Find the order row with this order number
                                matching_order = order_df[order_df['銷貨單號'] == order_num]
                                if not matching_order.empty:
                                    product_df.at[idx, key] = matching_order.iloc[0][key]
        
        st.session_state.debug_info.append(f"成功建立產品層級數據，共 {len(product_df)} 筆產品項目")
        
        # Debug output - log a sample of order totals to help diagnose inflated totals
        if not order_df.empty and '總計金額' in order_df.columns:
            total_sum = order_df['總計金額'].sum()
            st.session_state.debug_info.append(f"訂單總額核對: {total_sum}")
            
            # Show top 5 orders by amount
            top_orders = order_df.sort_values('總計金額', ascending=False).head(5)
            st.session_state.debug_info.append("最大金額訂單:")
            for idx, row in top_orders.iterrows():
                order_num = row['銷貨單號'] if '銷貨單號' in row else 'Unknown'
                amount = row['總計金額'] if '總計金額' in row else 0
                st.session_state.debug_info.append(f"  訂單 {order_num}: {amount}")
        
        return order_df, product_df
        
    except Exception as e:
        st.session_state.debug_info.append(f"分離數據層級時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None, None

def get_top_products(df, n=50):
    """
    Get the top N products from the data based on sales.
    
    This function works with the hierarchical data structure where product-level data
    is identified by rows with product information but potentially missing order-level info.
    """
    if df is None or df.empty:
        st.session_state.debug_info.append("無法獲取熱門產品: 數據為空")
        return None
    
    try:
        # Log information about the input DataFrame
        st.session_state.debug_info.append(f"開始分析產品數據，共 {len(df)} 行")
        
        # Display available columns to help with debugging
        st.session_state.debug_info.append(f"可用欄位: {', '.join(df.columns.tolist())}")
        
        # Check for presence of required columns
        required_cols = ["產品代號", "產品名稱", "數量", "小計"]
        missing_cols = [col for col in required_cols if col not in df.columns]
        
        if missing_cols:
            st.session_state.debug_info.append(f"缺少必要的產品欄位: {missing_cols}")
            
            # Try with alternative column names
            alternative_mappings = {
                "產品代號": ["商品代號", "品項代號", "SKU", "商品編號"],
                "產品名稱": ["商品名稱", "品項名稱", "商品說明"],
                "數量": ["購買數量", "銷售數量", "qty", "quantity"],
                "小計": ["金額", "總額", "產品金額", "銷售金額", "amount"]
            }
            
            # Check if we can find alternative columns
            alternative_cols = {}
            for missing_col in missing_cols:
                if missing_col in alternative_mappings:
                    for alt_col in alternative_mappings[missing_col]:
                        if alt_col in df.columns:
                            alternative_cols[missing_col] = alt_col
                            st.session_state.debug_info.append(f"將使用 '{alt_col}' 代替 '{missing_col}'")
                            break
            
            # If we still have missing columns, return None
            still_missing = [col for col in missing_cols if col not in alternative_cols]
            if still_missing:
                st.session_state.debug_info.append(f"無法找到替代欄位: {still_missing}")
                return None
            
            # Create a copy of the DataFrame with renamed columns
            working_df = df.copy()
            for original, alternative in alternative_cols.items():
                working_df[original] = working_df[alternative]
        else:
            working_df = df.copy()
        
        # Filter for product rows only - in hierarchical data, product rows typically have
        # product code and name but might be missing some order-level information
        if '銷貨單號' in working_df.columns:
            # For product rows in a hierarchical structure, filter appropriate rows
            # In your data structure, product rows might have empty order-level fields
            # Check the first few rows to see if we should filter
            sample_rows = working_df.head(10)
            has_hierarchical_structure = (sample_rows['產品代號'].notna().sum() > 0 and 
                                         sample_rows['銷貨單號'].isna().any())
            
            if has_hierarchical_structure:
                st.session_state.debug_info.append("檢測到分層數據結構，將篩選產品層級行")
                product_rows = working_df[working_df['產品代號'].notna()]
                st.session_state.debug_info.append(f"篩選後有 {len(product_rows)} 行產品數據")
            else:
                product_rows = working_df
        else:
            product_rows = working_df
        
        # Ensure numeric data types
        for col in ['數量', '小計']:
            if not pd.api.types.is_numeric_dtype(product_rows[col]):
                st.session_state.debug_info.append(f"將 {col} 轉換為數值類型")
                product_rows[col] = pd.to_numeric(product_rows[col], errors='coerce')
        
        # Drop rows with NaN in critical columns
        product_rows = product_rows.dropna(subset=['產品代號', '產品名稱', '數量', '小計'])
        st.session_state.debug_info.append(f"清理後有 {len(product_rows)} 行有效產品數據")
        
        if product_rows.empty:
            st.session_state.debug_info.append("清理後沒有有效的產品數據")
            return None
        
        # Sum quantities and amounts by product
        st.session_state.debug_info.append("開始按產品彙總銷售數據")
        product_summary = product_rows.groupby(["產品代號", "產品名稱"]).agg({
            "數量": "sum",
            "小計": "sum"
        }).reset_index()
        
        st.session_state.debug_info.append(f"彙總後有 {len(product_summary)} 個不同產品")
        
        # Sort by sales amount (小計) descending
        product_summary = product_summary.sort_values("小計", ascending=False)
        
        # Take top N products
        top_products = product_summary.head(n)
        
        # Add rank column
        top_products.insert(0, "排名", range(1, len(top_products) + 1))
        
        # Format 小計 for display
        top_products["小計"] = top_products["小計"].round(2).apply(lambda x: f"{x:,.2f}")
        
        st.session_state.debug_info.append(f"成功生成熱門產品列表，共 {len(top_products)} 項")
        
        # Show a sample of the top products
        if len(top_products) > 0:
            sample = top_products.head(3).to_dict('records')
            st.session_state.debug_info.append(f"熱門產品範例: {sample}")
        
        return top_products
    
    except Exception as e:
        st.session_state.debug_info.append(f"獲取熱門產品時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def convert_minguo_to_gregorian(date_str):
    """
    Convert date string from Minguo calendar (Taiwan) to Gregorian format.
    Example: "114.03.31" (Minguo) -> "2025-03-31" (Gregorian)
    """
    if not isinstance(date_str, str):
        return None
    
    # Handle different separators
    if '.' in date_str:
        parts = date_str.split('.')
    elif '/' in date_str:
        parts = date_str.split('/')
    elif '-' in date_str:
        parts = date_str.split('-')
    else:
        return None
    
    if len(parts) != 3:
        return None
    
    try:
        minguo_year = int(parts[0])
        month = int(parts[1])
        day = int(parts[2])
        
        # Convert Minguo year to Gregorian year (add 1911)
        gregorian_year = minguo_year + 1911
        
        # Return ISO format date string
        return f"{gregorian_year}-{month:02d}-{day:02d}"
    except:
        return None

def clean_numeric_value(value):
    """
    Clean numeric values by removing commas and converting to float.
    Example: "9,603" -> 9603.0
    """
    if pd.isna(value):
        return None
    
    if isinstance(value, (int, float)):
        return float(value)
    
    if not isinstance(value, str):
        return None
    
    # Remove commas and other non-numeric characters except for decimal points
    cleaned = value.replace(',', '')
    
    try:
        return float(cleaned)
    except:
        return None

def inspect_and_clean_data(df):
    """Inspect and clean data, providing details about critical columns."""
    if df is None or df.empty:
        st.session_state.debug_info.append("無法檢查數據：數據為空")
        return None
    
    st.session_state.debug_info.append(f"開始檢查和清理數據，原始數據有 {len(df)} 行")
    
    # Create a working copy
    cleaned_df = df.copy()
    
    # Check critical columns for report generation
    critical_columns = ['銷貨日期', '總計金額', '毛利']
    for col in critical_columns:
        if col not in cleaned_df.columns:
            st.session_state.debug_info.append(f"致命錯誤: 缺少必要欄位 {col}")
            return None
    
    # Check and convert 總計金額 column
    if '總計金額' in cleaned_df.columns:
        # Display sample values
        samples = cleaned_df['總計金額'].head(5).tolist()
        st.session_state.debug_info.append(f"總計金額 樣本值: {samples}")
        
        # Check data type
        original_type = cleaned_df['總計金額'].dtype
        st.session_state.debug_info.append(f"總計金額 原始類型: {original_type}")
        
        # Convert to numeric if needed
        if not pd.api.types.is_numeric_dtype(cleaned_df['總計金額']):
            st.session_state.debug_info.append("正在將總計金額轉換為數值類型...")
            try:
                # First, try cleaning the values by removing commas
                cleaned_df['總計金額'] = cleaned_df['總計金額'].apply(clean_numeric_value)
                
                # Report conversion results
                nan_count = cleaned_df['總計金額'].isna().sum()
                st.session_state.debug_info.append(f"轉換後有 {nan_count} 個空值")
                new_samples = cleaned_df['總計金額'].head(5).tolist()
                st.session_state.debug_info.append(f"轉換後的總計金額樣本: {new_samples}")
            except Exception as e:
                st.session_state.debug_info.append(f"轉換總計金額時出錯: {e}")
                return None
    
    # Check and convert 毛利 column
    if '毛利' in cleaned_df.columns:
        # Display sample values
        samples = cleaned_df['毛利'].head(5).tolist()
        st.session_state.debug_info.append(f"毛利 樣本值: {samples}")
        
        # Check data type
        original_type = cleaned_df['毛利'].dtype
        st.session_state.debug_info.append(f"毛利 原始類型: {original_type}")
        
        # Convert to numeric if needed
        if not pd.api.types.is_numeric_dtype(cleaned_df['毛利']):
            st.session_state.debug_info.append("正在將毛利轉換為數值類型...")
            try:
                # First, try cleaning the values by removing commas
                cleaned_df['毛利'] = cleaned_df['毛利'].apply(clean_numeric_value)
                
                # Report conversion results
                nan_count = cleaned_df['毛利'].isna().sum()
                st.session_state.debug_info.append(f"轉換後有 {nan_count} 個空值")
                new_samples = cleaned_df['毛利'].head(5).tolist()
                st.session_state.debug_info.append(f"轉換後的毛利樣本: {new_samples}")
            except Exception as e:
                st.session_state.debug_info.append(f"轉換毛利時出錯: {e}")
                return None
    
    # Check and convert 銷貨日期 column - special handling for Minguo calendar
    if '銷貨日期' in cleaned_df.columns:
        # Display sample values
        samples = cleaned_df['銷貨日期'].head(5).tolist()
        st.session_state.debug_info.append(f"銷貨日期 樣本值: {samples}")
        
        # Check data type
        original_type = cleaned_df['銷貨日期'].dtype
        st.session_state.debug_info.append(f"銷貨日期 原始類型: {original_type}")
        
        # Convert to datetime if needed
        if not pd.api.types.is_datetime64_dtype(cleaned_df['銷貨日期']):
            st.session_state.debug_info.append("正在將銷貨日期轉換為日期時間類型...")
            
            # Check if the date appears to be in Minguo format (Taiwan calendar)
            date_sample = str(samples[0]) if samples and samples[0] is not None else ""
            if isinstance(date_sample, str) and '.' in date_sample and len(date_sample.split('.')[0]) <= 3:
                st.session_state.debug_info.append("檢測到民國日期格式 (例如: 114.03.31)")
                try:
                    # Convert Minguo dates to Gregorian dates
                    gregorian_dates = []
                    for date_val in cleaned_df['銷貨日期']:
                        greg_date = convert_minguo_to_gregorian(str(date_val) if date_val is not None else "")
                        gregorian_dates.append(greg_date)
                    
                    # Create a new column with the converted dates
                    cleaned_df['銷貨日期_公曆'] = gregorian_dates
                    
                    # Convert to datetime
                    cleaned_df['銷貨日期'] = pd.to_datetime(cleaned_df['銷貨日期_公曆'], errors='coerce')
                    
                    # Drop the temporary column
                    cleaned_df = cleaned_df.drop('銷貨日期_公曆', axis=1)
                    
                    # Report conversion results
                    nan_count = cleaned_df['銷貨日期'].isna().sum()
                    st.session_state.debug_info.append(f"轉換後有 {nan_count} 個空值")
                    
                    # Show sample of converted dates
                    new_samples = cleaned_df['銷貨日期'].head(5).tolist()
                    st.session_state.debug_info.append(f"民國日期轉換後的樣本: {new_samples}")
                except Exception as e:
                    st.session_state.debug_info.append(f"轉換民國日期時出錯: {e}")
                    import traceback
                    st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
            else:
                # Try standard format conversions
                try:
                    if isinstance(date_sample, str) and '/' in date_sample:
                        st.session_state.debug_info.append("檢測到日期格式包含 '/'")
                        cleaned_df['銷貨日期'] = pd.to_datetime(cleaned_df['銷貨日期'], format='%Y/%m/%d', errors='coerce')
                    else:
                        cleaned_df['銷貨日期'] = pd.to_datetime(cleaned_df['銷貨日期'], errors='coerce')
                    
                    # Report conversion results
                    nan_count = cleaned_df['銷貨日期'].isna().sum()
                    st.session_state.debug_info.append(f"轉換後有 {nan_count} 個空值")
                    new_samples = cleaned_df['銷貨日期'].head(5).tolist()
                    st.session_state.debug_info.append(f"轉換後的銷貨日期樣本: {new_samples}")
                except Exception as e:
                    st.session_state.debug_info.append(f"標準日期轉換出錯: {e}")
    
    # Extract date components for grouping
    try:
        if pd.api.types.is_datetime64_dtype(cleaned_df['銷貨日期']):
            # Normal processing for datetime fields
            cleaned_df['年'] = cleaned_df['銷貨日期'].dt.year
            cleaned_df['月'] = cleaned_df['銷貨日期'].dt.month
            cleaned_df['年月'] = cleaned_df['銷貨日期'].dt.strftime('%Y-%m')
            
            # Check for missing values in the new columns
            year_na_count = cleaned_df['年'].isna().sum()
            month_na_count = cleaned_df['月'].isna().sum()
            yearmonth_na_count = cleaned_df['年月'].isna().sum()
            
            st.session_state.debug_info.append(f"日期欄位處理: 年有 {year_na_count} 個空值, 月有 {month_na_count} 個空值, 年月有 {yearmonth_na_count} 個空值")
            
            # Show some samples of the derived columns
            year_samples = cleaned_df['年'].head(5).tolist()
            month_samples = cleaned_df['月'].head(5).tolist()
            yearmonth_samples = cleaned_df['年月'].head(5).tolist()
            
            st.session_state.debug_info.append(f"年 樣本: {year_samples}")
            st.session_state.debug_info.append(f"月 樣本: {month_samples}")
            st.session_state.debug_info.append(f"年月 樣本: {yearmonth_samples}")
        else:
            # Manual extraction for dates that failed datetime conversion
            st.session_state.debug_info.append("銷貨日期轉換失敗，嘗試直接從原始民國日期提取年月...")
            
            # Check if we have the original date strings to work with
            if cleaned_df['銷貨日期'].dtype == 'object':
                # Extract from Minguo format like "114.03.31"
                # First, extract the year and add 1911 to convert to Gregorian
                cleaned_df['年'] = cleaned_df['銷貨日期'].astype(str).str.extract(r'^(\d{1,3})\.').astype(float) + 1911
                
                # Extract month
                cleaned_df['月'] = cleaned_df['銷貨日期'].astype(str).str.extract(r'\.(\d{1,2})\.').astype(float)
                
                # Create year-month string in the format YYYY-MM
                cleaned_df['年月'] = cleaned_df['年'].astype(int).astype(str) + '-' + cleaned_df['月'].astype(int).astype(str).str.zfill(2)
                
                # Check results
                sample_years = cleaned_df['年'].head(5).tolist()
                sample_months = cleaned_df['月'].head(5).tolist()
                sample_yearmonths = cleaned_df['年月'].head(5).tolist()
                
                st.session_state.debug_info.append(f"手動提取的年樣本: {sample_years}")
                st.session_state.debug_info.append(f"手動提取的月樣本: {sample_months}")
                st.session_state.debug_info.append(f"手動提取的年月樣本: {sample_yearmonths}")
            else:
                st.session_state.debug_info.append(f"無法識別的日期格式類型: {cleaned_df['銷貨日期'].dtype}")
                raise ValueError("無法識別的日期格式")
    
    except Exception as e:
        st.session_state.debug_info.append(f"提取日期元素時出錯: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        
        # As a fallback, create year/month columns for order rows based on file name pattern
        # This assumes file names have a date pattern like "_20250301_" (for March 1, 2025)
        try:
            st.session_state.debug_info.append("嘗試從檔案名稱提取日期資訊作為備用...")
            
            # Get the current filename from session state if available
            current_file = st.session_state.get('current_filename', '')
            
            # Extract date pattern like "20250301" from the filename
            import re
            date_match = re.search(r'_(\d{8})_', current_file)
            
            if date_match:
                date_str = date_match.group(1)
                year = int(date_str[:4])
                month = int(date_str[4:6])
                
                st.session_state.debug_info.append(f"從檔案名稱 '{current_file}' 中提取的日期: 年={year}, 月={month}")
                
                # Assign these values to all rows
                cleaned_df['年'] = year
                cleaned_df['月'] = month
                cleaned_df['年月'] = f"{year}-{month:02d}"
            else:
                # Just use current date as last resort
                st.session_state.debug_info.append("使用當前日期作為備用值")
                cleaned_df['年'] = datetime.now().year
                cleaned_df['月'] = datetime.now().month
                cleaned_df['年月'] = f"{datetime.now().year}-{datetime.now().month:02d}"
        except Exception as sub_e:
            st.session_state.debug_info.append(f"從檔案名稱提取日期失敗: {sub_e}")
            # Absolute last resort - use current date
            cleaned_df['年'] = datetime.now().year
            cleaned_df['月'] = datetime.now().month
            cleaned_df['年月'] = f"{datetime.now().year}-{datetime.now().month:02d}"
    
    # Verify critical columns are properly formatted
    for col in ['總計金額', '毛利']:
        if col in cleaned_df.columns and not pd.api.types.is_numeric_dtype(cleaned_df[col]):
            st.session_state.debug_info.append(f"嘗試再次轉換 {col} 為數值類型")
            try:
                cleaned_df[col] = pd.to_numeric(cleaned_df[col], errors='coerce')
            except:
                st.session_state.debug_info.append(f"致命錯誤: {col} 無法轉換為數值類型")
                return None
    
    # Check for the required columns for grouping
    if '年月' not in cleaned_df.columns:
        st.session_state.debug_info.append("致命錯誤: 無法生成年月欄位")
        return None
    
    # Final dataframe stats
    final_rows = len(cleaned_df)
    null_counts = {col: cleaned_df[col].isna().sum() for col in ['年月', '總計金額', '毛利'] if col in cleaned_df.columns}
    st.session_state.debug_info.append(f"數據清理完成，最終數據有 {final_rows} 行")
    st.session_state.debug_info.append(f"空值統計: {null_counts}")
    
    # Check if we have valid data for grouping - only for order-level rows
    if '銷貨單號' in cleaned_df.columns:
        valid_mask = cleaned_df['銷貨單號'].notna()
        valid_rows = cleaned_df[valid_mask].dropna(subset=['年月']).shape[0]
        st.session_state.debug_info.append(f"有效訂單行數: {valid_rows}")
        
        if valid_rows == 0:
            st.session_state.debug_info.append("警告: 沒有有效的訂單行可以進行匯總")
            return None
    else:
        valid_rows = cleaned_df.dropna(subset=['年月']).shape[0]
        st.session_state.debug_info.append(f"有效數據行數: {valid_rows}")
        
        if valid_rows == 0:
            st.session_state.debug_info.append("警告: 沒有有效的數據行可以進行匯總")
            return None
    
    return cleaned_df

def preprocess_hierarchical_excel(df):
    """
    Preprocess the raw Excel data that has a hierarchical structure with order-level and
    product-level rows. This function handles the layout pattern where:
    
    1. Order rows have populated order-level columns
    2. Product rows below have empty order-level columns (white space)
    3. This pattern repeats until the next order row
    
    Returns a cleaned dataframe that preserves the hierarchical relationship.
    """
    if df is None or df.empty:
        st.session_state.debug_info.append("預處理數據: 輸入數據為空")
        return None
    
    try:
        st.session_state.debug_info.append(f"開始預處理分層數據，原始數據有 {len(df)} 行")
        
        # First, check if we have the necessary columns
        order_col_check = '銷貨單號'  # A key column that should be populated for order rows
        if order_col_check not in df.columns:
            st.session_state.debug_info.append(f"預處理失敗: 找不到關鍵欄位 '{order_col_check}'")
            return None
        
        # Create a copy to avoid modifying the original
        processed_df = df.copy()
        
        # Identify which rows are order rows (have populated order-level columns)
        # and which are product rows (have empty order-level columns)
        order_rows = processed_df[order_col_check].notna()
        
        st.session_state.debug_info.append(f"識別出 {order_rows.sum()} 筆訂單行和 {len(order_rows) - order_rows.sum()} 筆產品行")
        
        # Now create a column that indicates which order each row belongs to
        processed_df['order_id_internal'] = None
        
        # For each order row, assign its index as the order_id_internal
        # For product rows, assign the order_id_internal of the previous order
        current_order_id = None
        for idx in processed_df.index:
            if order_rows[idx]:
                # This is an order row, use its own value as order_id
                current_order_id = processed_df.at[idx, order_col_check]
                processed_df.at[idx, 'order_id_internal'] = current_order_id
            else:
                # This is a product row, use the current order_id
                processed_df.at[idx, 'order_id_internal'] = current_order_id
        
        # Count how many product rows got assigned to orders
        assigned_products = processed_df[~order_rows]['order_id_internal'].notna().sum()
        st.session_state.debug_info.append(f"已為 {assigned_products} 筆產品項目分配訂單")
        
        # Now propagate order-level information to product rows that belong to each order
        for order_col in ORDER_LEVEL_COLUMNS:
            if order_col in processed_df.columns:
                # For each group of rows with the same order_id_internal, fill the NaN values
                # in order columns with the value from the order row
                # Using ffill() instead of fillna(method='ffill') to avoid FutureWarning
                processed_df[order_col] = processed_df.groupby('order_id_internal')[order_col].transform(
                    lambda x: x.ffill()
                )
        
        # Drop the temporary column
        processed_df = processed_df.drop('order_id_internal', axis=1)
        
        st.session_state.debug_info.append(f"預處理完成，保留了 {len(processed_df)} 行數據")
        return processed_df
        
    except Exception as e:
        st.session_state.debug_info.append(f"預處理分層數據時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def process_sales_data(df_list, filenames=None):
    """
    Process sales data from multiple DataFrames with hierarchical structure.
    The filenames parameter is used to extract date information as a fallback.
    """
    if not df_list:
        st.session_state.debug_info.append("處理銷售數據: 沒有提供數據框")
        return None
    
    # Store filenames for potential date extraction
    if filenames and len(filenames) > 0:
        st.session_state.current_filename = filenames[0]
        st.session_state.debug_info.append(f"設定當前檔案名稱: {st.session_state.current_filename}")
    
    # Combine all DataFrames
    try:
        # Process each dataframe to handle the hierarchical structure before combining
        processed_dfs = []
        for i, df in enumerate(df_list):
            current_file = filenames[i] if filenames and i < len(filenames) else f"檔案 {i+1}"
            st.session_state.debug_info.append(f"正在處理 {current_file}，原始行數: {len(df)}")
            processed_df = preprocess_hierarchical_excel(df)
            if processed_df is not None:
                processed_dfs.append(processed_df)
        
        if not processed_dfs:
            st.session_state.debug_info.append("預處理後沒有可用的數據框")
            return None
        
        # Combine the processed DataFrames
        combined_df = pd.concat(processed_dfs, ignore_index=True)
        st.session_state.debug_info.append(f"成功合併 {len(processed_dfs)} 個處理後的數據檔案，共 {len(combined_df)} 行")
        
        # Check for any data in the DataFrame
        if combined_df.empty:
            st.session_state.debug_info.append("合併後的銷售數據為空")
            return None
        
        # Inspect and clean the data
        cleaned_df = inspect_and_clean_data(combined_df)
        
        # Split into order and product level
        if cleaned_df is not None:
            order_df, product_df = split_data_levels(cleaned_df)
            st.session_state.processed_data['order_level'] = order_df
            st.session_state.processed_data['product_level'] = product_df
            
            # Show order level stats
            if order_df is not None and not order_df.empty:
                # Count non-null values in key columns
                totals_count = order_df['總計金額'].notna().sum()
                profit_count = order_df['毛利'].notna().sum()
                date_count = order_df['銷貨日期'].notna().sum()
                
                st.session_state.debug_info.append(f"訂單層級統計: {len(order_df)} 筆訂單")
                st.session_state.debug_info.append(f"訂單層級有效值: 總計金額 {totals_count}, 毛利 {profit_count}, 銷貨日期 {date_count}")
        
        return cleaned_df
        
    except Exception as e:
        st.session_state.debug_info.append(f"處理銷售數據時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def generate_monthly_sales_report(df):
    """
    Generate monthly sales report from processed data.
    
    This function is designed to work with hierarchical data where order-level
    rows contain sales totals and dates. Only the order-level rows should be used
    for generating the monthly summary to avoid double-counting.
    """
    # 非常重要：直接使用已處理的訂單層級數據，而不是傳入的 df
    if st.session_state.processed_data['order_level'] is not None:
        # 使用訂單層級數據
        order_df = st.session_state.processed_data['order_level'].copy()
        st.session_state.debug_info.append(f"直接使用訂單層級數據：{len(order_df)} 行，而非完整資料 {len(df)} 行")
    else:
        st.session_state.debug_info.append("無法找到訂單層級數據")
        return None
    
    # 檢查必要欄位
    if not all(col in order_df.columns for col in ['年月', '總計金額', '毛利']):
        st.session_state.debug_info.append("訂單層級數據缺少必要欄位")
        return None
    
    # 記錄總金額作為參考
    total_amount = order_df['總計金額'].sum()
    st.session_state.debug_info.append(f"訂單層級總計金額：{total_amount}")
    
    # 按月份分組
    monthly_report = order_df.groupby('年月').agg({
        '總計金額': 'sum',
        '毛利': 'sum'
    }).reset_index()
    
    # 計算毛利率
    monthly_report['毛利率'] = (monthly_report['毛利'] / monthly_report['總計金額']) * 100
    
    # 排序
    monthly_report = monthly_report.sort_values('年月')
    
    # 紀錄結果
    st.session_state.debug_info.append(f"月度報表生成成功，共 {len(monthly_report)} 個月份")
    st.session_state.debug_info.append(f"月度報表總計金額：{monthly_report['總計金額'].sum()}")
    
    # 顯示樣本
    sample_data = monthly_report.head().to_dict('records')
    st.session_state.debug_info.append(f"月度報表樣本：{sample_data}")
    
    # 儲存到 session state
    st.session_state.processed_data['monthly_summary'] = monthly_report
    
    return monthly_report

def create_sales_charts(df):
    """Create visualizations for sales data."""
    if df is None or df.empty:
        st.session_state.debug_info.append("無法生成圖表: 輸入數據為空")
        return None, None
    
    try:
        # Ensure data is properly formatted for charts
        if '年月' not in df.columns or '總計金額' not in df.columns or '毛利' not in df.columns:
            st.session_state.debug_info.append(f"繪製圖表失敗: 缺少必要欄位。現有欄位: {df.columns.tolist()}")
            return None, None
        
        # Monthly sales trend chart
        sales_fig = px.line(
            df, x='年月', y='總計金額', 
            title='月度營業額趨勢',
            labels={'年月': '年月', '總計金額': '營業額 (元)'},
            markers=True
        )
        sales_fig.update_layout(
            xaxis_title='年月',
            yaxis_title='營業額 (元)',
            height=400
        )
        
        # Monthly profit trend chart
        profit_fig = px.line(
            df, x='年月', y=['毛利', '毛利率'], 
            title='月度毛利趨勢',
            labels={'年月': '年月', 'value': '金額/百分比', 'variable': '指標'},
            markers=True
        )
        profit_fig.update_layout(
            xaxis_title='年月',
            yaxis_title='金額/百分比',
            height=400
        )
        
        st.session_state.debug_info.append("圖表生成成功")
        return sales_fig, profit_fig
        
    except Exception as e:
        st.session_state.debug_info.append(f"生成圖表時發生錯誤: {e}")
        return None, None

def create_monthly_comparison_chart(order_df):
    """
    Create a daily revenue comparison chart for multiple months.
    Each month will be represented by a different colored line.
    
    Args:
        order_df: DataFrame containing order-level data with dates and amounts
    
    Returns:
        A plotly figure object with the comparison chart
    """
    if order_df is None or order_df.empty:
        st.session_state.debug_info.append("無法生成月度比較圖表: 訂單數據為空")
        return None
    
    try:
        # Check if required columns exist
        if '銷貨日期' not in order_df.columns or '總計金額' not in order_df.columns:
            st.session_state.debug_info.append("生成月度比較圖表失敗: 缺少銷貨日期或總計金額欄位")
            return None
        
        # Ensure date column is datetime type
        if not pd.api.types.is_datetime64_dtype(order_df['銷貨日期']):
            st.session_state.debug_info.append("將銷貨日期轉換為日期時間格式以進行比較")
            order_df['銷貨日期'] = pd.to_datetime(order_df['銷貨日期'], errors='coerce')
        
        # Extract year-month and day for grouping
        order_df['年月'] = order_df['銷貨日期'].dt.strftime('%Y-%m')
        order_df['日'] = order_df['銷貨日期'].dt.day
        
        # Get unique months
        months = order_df['年月'].unique()
        
        # If there's only one month, we can't do a comparison
        if len(months) <= 1:
            st.session_state.debug_info.append(f"只有一個月份的數據 ({months[0]})，無法進行比較")
            return None
        
        st.session_state.debug_info.append(f"找到 {len(months)} 個不同月份: {', '.join(months)}")
        
        # Group by year-month and day, summing the total amount
        daily_sales = order_df.groupby(['年月', '日'])['總計金額'].sum().reset_index()
        
        # Create figure
        fig = go.Figure()
        
        # Add a line for each month with different colors
        for month in months:
            month_data = daily_sales[daily_sales['年月'] == month].copy()
            
            # Skip if no data for this month
            if month_data.empty:
                continue
                
            # Sort by day
            month_data = month_data.sort_values('日')
            
            # Add line with month name in legend
            fig.add_trace(go.Scatter(
                x=month_data['日'],
                y=month_data['總計金額'],
                mode='lines+markers',
                name=month,
                hovertemplate='日期: %{x}日<br>金額: $%{y:,.2f}'
            ))
        
        # Update layout
        fig.update_layout(
            title='各月份每日銷售金額比較',
            xaxis_title='日期',
            yaxis_title='銷售金額 (元)',
            legend_title='月份',
            xaxis=dict(
                tickmode='linear',
                tick0=1,
                dtick=1
            ),
            height=500,
            margin=dict(l=40, r=40, t=50, b=40)
        )
        
        return fig
        
    except Exception as e:
        st.session_state.debug_info.append(f"生成月度比較圖表時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

def create_monthly_comparison_table(monthly_summary):
    """
    Create a comparison table for monthly sales data.
    
    Args:
        monthly_summary: DataFrame containing monthly summary data
    
    Returns:
        A formatted DataFrame for display
    """
    if monthly_summary is None or monthly_summary.empty:
        st.session_state.debug_info.append("無法生成月度比較表: 月度摘要數據為空")
        return None
    
    try:
        # Check if required columns exist
        required_cols = ['年月', '總計金額', '毛利']
        missing_cols = [col for col in required_cols if col not in monthly_summary.columns]
        if missing_cols:
            st.session_state.debug_info.append(f"生成月度比較表失敗: 缺少必要欄位 {', '.join(missing_cols)}")
            return None
        
        # Make a copy to avoid modifying the original
        comparison_df = monthly_summary.copy()
        
        # Sort by year-month
        comparison_df = comparison_df.sort_values('年月')
        
        # Create growth rate columns
        comparison_df['銷售成長率'] = comparison_df['總計金額'].pct_change() * 100
        comparison_df['毛利成長率'] = comparison_df['毛利'].pct_change() * 100
        
        # Calculate month-over-month growth for each row
        if '毛利' in comparison_df.columns and '總計金額' in comparison_df.columns:
            comparison_df['毛利率'] = (comparison_df['毛利'] / comparison_df['總計金額']) * 100
            comparison_df['毛利率變化'] = comparison_df['毛利率'].diff()
        
        # Format currency columns
        for col in ['總計金額', '毛利']:
            if col in comparison_df.columns:
                comparison_df[col] = comparison_df[col].map('${:,.2f}'.format)
        
        # Format percentage columns
        for col in ['銷售成長率', '毛利成長率']:
            if col in comparison_df.columns:
                comparison_df[col] = comparison_df[col].map('{:+.2f}%'.format)
        
        if '毛利率' in comparison_df.columns:
            comparison_df['毛利率'] = comparison_df['毛利率'].map('{:.2f}%'.format)
        
        if '毛利率變化' in comparison_df.columns:
            comparison_df['毛利率變化'] = comparison_df['毛利率變化'].map('{:+.2f}%'.format)
        
        # Rename columns for display
        column_rename = {
            '年月': '月份',
            '總計金額': '總銷售額',
            '毛利': '總毛利',
            '毛利率': '毛利率',
            '銷售成長率': '銷售成長',
            '毛利成長率': '毛利成長',
            '毛利率變化': '毛利率變化'
        }
        
        display_df = comparison_df.rename(columns=column_rename)
        
        # Reorder columns for clarity
        column_order = ['月份', '總銷售額', '銷售成長', '總毛利', '毛利成長', '毛利率', '毛利率變化']
        display_df = display_df[[col for col in column_order if col in display_df.columns]]
        
        return display_df
        
    except Exception as e:
        st.session_state.debug_info.append(f"生成月度比較表時發生錯誤: {e}")
        import traceback
        st.session_state.debug_info.append(f"錯誤詳情: {traceback.format_exc()}")
        return None

# Version 1.1: Added Daily Sales Chart function
def create_daily_sales_chart(order_df, selected_month=None):
    """
    Create a bar chart showing daily sales within a specific month.
    
    Args:
        order_df: DataFrame containing order-level data with dates and amounts
        selected_month: The month to display (format: 'YYYY-MM'), if None, uses the most recent month
    
    Returns:
        A tuple containing (plotly figure object, list of available months)
    """
    import plotly.graph_objects as go
    import pandas as pd
    from datetime import datetime
    
    if order_df is None or order_df.empty:
        st.warning("無法生成日銷售圖表: 訂單數據為空")
        return None, []
    
    try:
        # Check if required columns exist
        if '銷貨日期' not in order_df.columns or '總計金額' not in order_df.columns:
            st.warning("生成日銷售圖表失敗: 缺少銷貨日期或總計金額欄位")
            return None, []
        
        # Ensure date column is datetime type
        if not pd.api.types.is_datetime64_dtype(order_df['銷貨日期']):
            st.session_state.debug_info.append("將銷貨日期轉換為日期時間格式以生成日銷售圖")
            order_df['銷貨日期'] = pd.to_datetime(order_df['銷貨日期'], errors='coerce')
        
        # Drop rows where date conversion failed
        order_df = order_df.dropna(subset=['銷貨日期'])
        if order_df.empty:
            st.warning("日期轉換後沒有有效的數據")
            return None, []

        # Extract year-month and day for grouping
        order_df['年月'] = order_df['銷貨日期'].dt.strftime('%Y-%m')
        order_df['日'] = order_df['銷貨日期'].dt.day
        
        # Get unique months for selection
        months = sorted(order_df['年月'].unique(), reverse=True)
        
        if not months:
            st.warning("找不到有效的月份數據")
            return None, []
        
        # If no month selected or selected month not in data, use most recent
        if selected_month is None or selected_month not in months:
            selected_month = months[0]  # Most recent month
        
        # Filter data for the selected month
        month_data = order_df[order_df['年月'] == selected_month].copy()
        
        if month_data.empty:
            st.warning(f"所選月份 {selected_month} 沒有銷售數據")
            # Return an empty chart structure but still provide months for selection
            fig = go.Figure()
            fig.update_layout(title=f'{selected_month} 日銷售金額 - 無數據')
            return fig, months
        
        # Group by day and sum total amount
        daily_sales = month_data.groupby('日')['總計金額'].sum().reset_index()
        
        # Sort by day
        daily_sales = daily_sales.sort_values('日')
        
        # Create figure
        fig = go.Figure()
        
        # Add bar chart
        fig.add_trace(go.Bar(
            x=daily_sales['日'],
            y=daily_sales['總計金額'],
            text=daily_sales['總計金額'].apply(lambda x: f"${x:,.2f}"),
            textposition='auto',
            marker_color='#0d6efd', # Bootstrap primary blue
            hovertemplate='%{x}日: $%{y:,.2f}<extra></extra>' # Use <extra></extra> to hide trace info
        ))
        
        # Calculate month total for annotation
        month_total = daily_sales['總計金額'].sum()
        
        # Update layout with improved styling
        fig.update_layout(
            title=f'{selected_month} 日銷售金額',
            xaxis_title='日期',
            yaxis_title='銷售金額 (元)',
            xaxis=dict(
                tickmode='linear', # Ensure all days are shown
                tick0=1,
                dtick=1,
                tickangle=0 # Keep labels horizontal
            ),
            yaxis=dict(
                tickformat="$,.2f" # Format y-axis labels as currency
            ),
            height=500,
            margin=dict(l=40, r=40, t=60, b=40), # Adjusted top margin for annotation
            annotations=[
                dict(
                    x=0.5, 
                    y=1.08, # Position above the title
                    xref='paper', 
                    yref='paper',
                    text=f'月總計: ${month_total:,.2f}',
                    showarrow=False,
                    font=dict(size=16, color="#333")
                )
            ],
            hovermode='x unified' # Show hover info for the specific day
        )
        
        return fig, months
        
    except Exception as e:
        st.error(f"生成日銷售圖表時發生錯誤: {e}")
        import traceback
        st.error(f"錯誤詳情: {traceback.format_exc()}")
        # Return empty structure on error but provide available months if possible
        months = []
        if '年月' in order_df.columns:
             months = sorted(order_df['年月'].unique(), reverse=True)
        return None, months

# --------------------------------------------------
# 📊 STREAMLIT UI ---------------------------------
# --------------------------------------------------

# Setup sidebar for all functionality
with st.sidebar:
    st.header("資料上傳")
    
    # Data structure definitions (expandable)
    with st.expander("數據欄位定義", expanded=False):
        # Order Level Tab
        st.markdown("#### 訂單層級欄位定義")
        for col in ORDER_LEVEL_COLUMNS:
            definition = COLUMN_DEFINITIONS.get(col, "無描述")
            st.markdown(f"**{col}**: {definition}")
        
        st.markdown("---")
        
        # Product Level Tab
        st.markdown("#### 產品層級欄位定義")
        for col in PRODUCT_LEVEL_COLUMNS:
            definition = COLUMN_DEFINITIONS.get(col, "無描述")
            st.markdown(f"**{col}**: {definition}")
        
        st.markdown("---")
        
        # BC Tab
        st.markdown("#### BC 產品欄位定義")
        for col in BC_COLUMNS:
            if col not in ORDER_LEVEL_COLUMNS and col not in PRODUCT_LEVEL_COLUMNS:
                definition = COLUMN_DEFINITIONS.get(col, "無描述")
                st.markdown(f"**{col}**: {definition}")
    
    # Sales Data Section
    st.markdown("### 銷貨資料上傳")
    with st.expander("必要欄位列表", expanded=False):
        st.markdown("""
        **訂單層級欄位：**
        銷貨單號, 訂單單號, 銷貨日期, 客戶代號, 客戶名稱, 部門代號, 部門名稱, 發票號碼, 
        未稅小計, 營業稅, 折讓金額, 稅前折價, 總計金額, 實收總額, 成本總額, 毛利, 毛利率
        
        **產品層級欄位：**
        產品代號, 產品名稱, 倉別代號, 倉別名稱, 數量, 單位, 單價, 小計, 成本總值, 產品毛利, 
        產品毛利率, 銷售單價1, 精準成本, 精準毛利, 單位管銷成本, 管銷成本合計, *銷貨日期, 
        *客戶代號, *客戶條件, *部門代號, *業務代號, *業務條件
        """)
    
    sales_view = st.radio(
        "選擇操作:",
        ["上傳新檔案", "使用已上傳的檔案"],
        horizontal=True,
        key="sales_view_option",
        label_visibility="collapsed"
    )
    
    if sales_view == "上傳新檔案":
        sales_files = st.file_uploader(
            "上傳銷貨單毛利分析表 (可多選)",
            type=["xlsx", "xls"],
            accept_multiple_files=True,
            key="sales_uploader"
        )
        
        if sales_files:
            saved_paths = []
            with st.spinner("正在儲存上傳的銷貨檔案..."):
                for file in sales_files:
                    saved_path = save_uploaded_file(file, UPLOADED_SALES_DIR)
                    if saved_path: 
                        saved_paths.append(saved_path)
                        
            if len(saved_paths) == len(sales_files):
                st.success(f"已成功儲存 {len(saved_paths)} 個銷貨檔案。")
                st.session_state.sales_files_uploaded = True
                
                # Load and process data
                try:
                    dfs = []
                    filenames = []
                    for file in sales_files:
                        try:
                            df = pd.read_excel(file)
                            if not df.empty:
                                dfs.append(df)
                                filenames.append(file.name)
                                st.session_state.debug_info.append(f"成功讀取 {file.name}，有 {len(df)} 行")
                            else:
                                st.session_state.debug_info.append(f"警告: {file.name} 檔案為空")
                        except Exception as e:
                            st.session_state.debug_info.append(f"讀取 {file.name} 時發生錯誤: {e}")
                    
                    if dfs:
                        st.session_state.sales_data = process_sales_data(dfs, filenames)
                        generate_monthly_sales_report(st.session_state.sales_data)
                    else:
                        st.session_state.debug_info.append("沒有成功讀取任何銷售檔案")
                except Exception as e:
                    st.session_state.debug_info.append(f"處理銷售檔案時發生錯誤: {e}")
            else: 
                st.warning("部分銷貨檔案儲存失敗。")
            
            # Show preview of the first file
            if sales_files:
                with st.expander("資料預覽 (首個檔案)"):
                    try:
                        preview_df = pd.read_excel(sales_files[0])
                        st.dataframe(preview_df.head())
                        
                        # Display sample values from important columns
                        if not preview_df.empty:
                            st.write("重要欄位樣本:")
                            for col in ['銷貨日期', '總計金額', '毛利']:
                                if col in preview_df.columns:
                                    st.write(f"{col} 前5筆: {preview_df[col].head().tolist()}")
                                    st.write(f"{col} 數據類型: {preview_df[col].dtype}")
                    except Exception as e:
                        st.error(f"預覽檔案時發生錯誤: {e}")
    else:
        available_sales_files = get_uploaded_files(UPLOADED_SALES_DIR)
        if not available_sales_files:
            st.info(f"'{UPLOADED_SALES_DIR}' 目錄下沒有找到任何銷貨檔案。")
            st.session_state.sales_files_uploaded = False
        else:
            selected_files = st.multiselect(
                "選擇要使用的檔案:",
                options=available_sales_files
            )
            
            if selected_files:
                st.session_state.sales_files_uploaded = True
                
                # Load and process selected files
                try:
                    dfs = []
                    filenames = []
                    for file in selected_files:
                        file_path = os.path.join(UPLOADED_SALES_DIR, file)
                        try:
                            df = pd.read_excel(file_path)
                            if not df.empty:
                                dfs.append(df)
                                filenames.append(file)
                                st.session_state.debug_info.append(f"成功讀取 {file}，有 {len(df)} 行")
                            else:
                                st.session_state.debug_info.append(f"警告: {file} 檔案為空")
                        except Exception as e:
                            st.session_state.debug_info.append(f"讀取檔案 '{file}' 時發生錯誤: {e}")
                    
                    if dfs:
                        st.session_state.sales_data = process_sales_data(dfs, filenames)
                        generate_monthly_sales_report(st.session_state.sales_data)
                    else:
                        st.session_state.debug_info.append("沒有成功讀取任何銷售檔案")
                except Exception as e:
                    st.session_state.debug_info.append(f"處理銷售檔案時發生錯誤: {e}")
                
                # Show preview of first selected file
                if selected_files:
                    with st.expander(f"資料預覽: {selected_files[0]}"):
                        try:
                            file_path = os.path.join(UPLOADED_SALES_DIR, selected_files[0])
                            preview_df = pd.read_excel(file_path)
                            st.dataframe(preview_df.head())
                            
                            # Display sample values from important columns
                            if not preview_df.empty:
                                st.write("重要欄位樣本:")
                                for col in ['銷貨日期', '總計金額', '毛利']:
                                    if col in preview_df.columns:
                                        st.write(f"{col} 前5筆: {preview_df[col].head().tolist()}")
                                        st.write(f"{col} 數據類型: {preview_df[col].dtype}")
                        except Exception as e:
                            st.error(f"預覽檔案時發生錯誤: {e}")
    
    st.markdown("---")
    
    # BC Inventory Data Section
    st.markdown("### BC 產品資料上傳")
    with st.expander("必要欄位列表", expanded=False):
        st.markdown("""
        **必要欄位：**
        產品代號, 產品名稱, 數量, 倉庫, 單位, 成本單價, 成本總價, 安全存量, 廠商代號, 
        廠商簡稱, 最後出貨日, 最後進貨日, 銷售單價1, 銷售單價2, 銷售單價3, 銷售單價4, 
        最低售價, 數量為零自動下架, 持續上架, 停止上架, 大類名稱, 中類名稱, 小類名稱, 
        備註, EAN13碼, CO128碼, 建議售價, 毛利率
        """)
    
    bc_view = st.radio(
        "選擇操作:",
        ["上傳新檔案", "使用已上傳的檔案"],
        horizontal=True,
        key="bc_view_option",
        label_visibility="collapsed"
    )
    
    if bc_view == "上傳新檔案":
        bc_file = st.file_uploader(
            "上傳 BC 產品 SKU 表",
            type=["xlsx", "xls"],
            key="bc_uploader"
        )
        
        if bc_file:
            with st.spinner("正在儲存上傳的 BC 檔案..."):
                saved_bc_path = save_uploaded_file(bc_file, UPLOADED_BC_DIR)
            
            if saved_bc_path: 
                st.success(f"已成功儲存 BC 檔案: {bc_file.name}")
                st.session_state.bc_file_uploaded = True
                
                # Load BC data
                try:
                    st.session_state.bc_data = pd.read_excel(bc_file)
                    st.session_state.debug_info.append(f"成功讀取 BC 檔案 {bc_file.name}，有 {len(st.session_state.bc_data)} 行")
                except Exception as e:
                    st.session_state.debug_info.append(f"讀取 BC 檔案時發生錯誤: {e}")
            else: 
                st.error("儲存 BC 檔案失敗。")
            
            # Show preview
            with st.expander("資料預覽"):
                try:
                    preview_bc_df = pd.read_excel(bc_file)
                    st.dataframe(preview_bc_df.head())
                except Exception as e:
                    st.error(f"預覽 BC 檔案時發生錯誤: {e}")
    else:
        available_bc_files = get_uploaded_files(UPLOADED_BC_DIR)
        if not available_bc_files:
            st.info(f"'{UPLOADED_BC_DIR}' 目錄下沒有找到任何 BC 檔案。")
            st.session_state.bc_file_uploaded = False
        else:
            selected_bc_file = st.selectbox(
                "選擇要使用的 BC 檔案:",
                options=["請選擇..."] + available_bc_files,
                key="bc_file_selector"
            )
            
            if selected_bc_file and selected_bc_file != "請選擇...":
                st.session_state.bc_file_uploaded = True
                
                # Load selected BC file
                file_path = os.path.join(UPLOADED_BC_DIR, selected_bc_file)
                try:
                    st.session_state.bc_data = pd.read_excel(file_path)
                    st.session_state.debug_info.append(f"成功讀取 BC 檔案 {selected_bc_file}，有 {len(st.session_state.bc_data)} 行")
                except Exception as e:
                    st.session_state.debug_info.append(f"讀取 BC 檔案時發生錯誤: {e}")
                
                with st.expander(f"預覽: {selected_bc_file}"):
                    try:
                        preview_bc_df = pd.read_excel(file_path)
                        st.dataframe(preview_bc_df.head())
                    except Exception as e:
                        st.error(f"預覽 BC 檔案時發生錯誤: {e}")
    
    st.markdown("---")
    
    # Generate button in sidebar
    if st.button("分析並更新報表", key="analyze_button", help="分析數據並生成報表", use_container_width=True, type="primary"):
        st.session_state.analyze_triggered = True
        st.session_state.debug_info = []  # Reset debug info on new analysis
        st.session_state.debug_info.append("開始新的分析...")
        
        # Run analysis when button is clicked
        if st.session_state.sales_data is not None:
            generate_monthly_sales_report(st.session_state.sales_data)
    else:
        if 'analyze_triggered' not in st.session_state:
            st.session_state.analyze_triggered = False
    
    # Debug toggle
    show_debug = st.checkbox("顯示除錯資訊", value=True)
    
    # Show debug information if enabled
    if show_debug and st.session_state.debug_info:
        with st.expander("除錯資訊", expanded=True):
            for info in st.session_state.debug_info:
                st.text(info)

# Main content area
# Page title
st.markdown("<h1 style='text-align: center;'>數據圖表生成器</h1>", unsafe_allow_html=True)

# Display processing status directly without showing data structure information

# Display processing status
status_cols = st.columns(3)

with status_cols[0]:
    if st.session_state.processed_data['order_level'] is not None:
        st.success(f"已成功處理 {len(st.session_state.processed_data['order_level'])} 筆訂單資料")
    
with status_cols[1]:
    if st.session_state.processed_data['product_level'] is not None:
        st.success(f"已成功處理 {len(st.session_state.processed_data['product_level'])} 筆產品資料")
    
with status_cols[2]:
    if st.session_state.processed_data['monthly_summary'] is not None:
        st.success(f"已生成 {len(st.session_state.processed_data['monthly_summary'])} 個月的銷售報表")

# Add a big visual for the total 總計金額
if st.session_state.processed_data['order_level'] is not None:
    # Get the order-level data
    order_df = st.session_state.processed_data['order_level']
    
    # Debug the processed data
    st.session_state.debug_info.append(f"計算總計金額: 訂單資料有 {len(order_df)} 行")
    if '銷貨單號' in order_df.columns:
        unique_orders = order_df['銷貨單號'].nunique()
        st.session_state.debug_info.append(f"計算總計金額: 有 {unique_orders} 個唯一訂單號")
    
    # Use 總計金額 (Total Amount) for the total sales revenue after taxes
    if '總計金額' in order_df.columns:
        # Ensure the value is numeric before formatting
        try:
            # Convert to numeric if not already
            if not pd.api.types.is_numeric_dtype(order_df['總計金額']):
                order_df['總計金額'] = pd.to_numeric(order_df['總計金額'], errors='coerce')
            
            # Check for duplicates in order data
            if '銷貨單號' in order_df.columns:
                has_duplicates = order_df['銷貨單號'].duplicated().any()
                if has_duplicates:
                    st.session_state.debug_info.append("警告: 發現重複訂單號，使用去重複後的數據計算總額")
                    # Use unique orders to calculate totals
                    unique_order_df = order_df.drop_duplicates(subset=['銷貨單號'])
                    total_amount = unique_order_df['總計金額'].sum()
                    
                    # Log for diagnostics
                    st.session_state.debug_info.append(f"去重複前總額: {order_df['總計金額'].sum()}")
                    st.session_state.debug_info.append(f"去重複後總額: {total_amount}")
                else:
                    total_amount = order_df['總計金額'].sum()
            else:
                total_amount = order_df['總計金額'].sum()
            
            # Sample of order amounts for verification
            sample_amounts = order_df['總計金額'].sample(min(5, len(order_df))).tolist()
            st.session_state.debug_info.append(f"訂單金額樣本: {sample_amounts}")
            
            # Format the number for display
            formatted_amount = f"${total_amount:,.2f}" if pd.notna(total_amount) else "$0.00"
            
            # Display the total in a large, prominent format
            st.markdown("### 銷售總覽")
            
            # Use a container with border and styling
            with st.container(border=True):
                # Create a big centered header for the total
                st.markdown(
                    f"""
                    <div style="text-align: center; padding: 2rem 0;">
                        <h2 style="font-size: 1.5rem; color: #555;">總銷售金額 (總計金額)</h2>
                        <h1 style="font-size: 3rem; font-weight: bold; color: #0f5132;">{formatted_amount}</h1>
                    </div>
                    """,
                    unsafe_allow_html=True
                )
        except Exception as e:
            st.error(f"計算實收總額時發生錯誤: {e}")
            st.markdown("### 銷售總覽")
            with st.container(border=True):
                st.markdown(
                    """
                    <div style="text-align: center; padding: 2rem 0;">
                        <h2 style="font-size: 1.5rem; color: #555;">總銷售金額 (實收總額)</h2>
                        <h1 style="font-size: 3rem; font-weight: bold; color: #0f5132;">$0.00</h1>
                        <p style="color: #dc3545;">無法計算總額，請檢查數據格式</p>
                    </div>
                    """,
                    unsafe_allow_html=True
                )
        
        # If we have profit data, show that as well
        if '毛利' in order_df.columns:
            try:
                # Ensure the value is numeric before formatting
                if not pd.api.types.is_numeric_dtype(order_df['毛利']):
                    order_df['毛利'] = pd.to_numeric(order_df['毛利'], errors='coerce')
                
                # Use the same approach as for total_amount to handle potential duplicates
                if '銷貨單號' in order_df.columns and order_df['銷貨單號'].duplicated().any():
                    # Use unique orders to calculate totals
                    unique_order_df = order_df.drop_duplicates(subset=['銷貨單號'])
                    total_profit = unique_order_df['毛利'].sum()
                    
                    # Log for diagnostics
                    st.session_state.debug_info.append(f"去重複前毛利總額: {order_df['毛利'].sum()}")
                    st.session_state.debug_info.append(f"去重複後毛利總額: {total_profit}")
                else:
                    total_profit = order_df['毛利'].sum()
                
                # Sample of profit amounts for verification
                sample_profits = order_df['毛利'].sample(min(5, len(order_df))).tolist()
                st.session_state.debug_info.append(f"毛利樣本: {sample_profits}")
                
                # Format for display
                formatted_profit = f"${total_profit:,.2f}" if pd.notna(total_profit) else "$0.00"
                
                # Display the total gross profit
                col1, col2 = st.columns(2)
                
                with col1:
                    with st.container(border=True):
                        st.markdown(
                            f"""
                            <div style="text-align: center; padding: 1rem 0;">
                                <h3 style="font-size: 1.2rem; color: #555;">總毛利</h3>
                                <h2 style="font-size: 2rem; font-weight: bold; color: #0d6efd;">{formatted_profit}</h2>
                            </div>
                            """,
                            unsafe_allow_html=True
                        )
                
                # For profit margin, use the average of the 毛利率 column if available
                if '毛利率' in order_df.columns:
                    try:
                        # Ensure the value is numeric before calculating
                        if not pd.api.types.is_numeric_dtype(order_df['毛利率']):
                            order_df['毛利率'] = pd.to_numeric(order_df['毛利率'], errors='coerce')
                            
                        # Use the same DataFrame as for other calculations
                        if '銷貨單號' in order_df.columns and order_df['銷貨單號'].duplicated().any():
                            unique_order_df = order_df.drop_duplicates(subset=['銷貨單號'])
                            avg_profit_margin = unique_order_df['毛利率'].dropna().mean()
                        else:
                            avg_profit_margin = order_df['毛利率'].dropna().mean()
                        
                        # Format for display
                        formatted_margin = f"{avg_profit_margin:.2f}%" if pd.notna(avg_profit_margin) else "0.00%"
                        
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    f"""
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">平均毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">{formatted_margin}</h2>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                    except Exception as e:
                        st.error(f"計算平均毛利率時發生錯誤: {e}")
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    """
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">平均毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">0.00%</h2>
                                        <p style="color: #dc3545;">無法計算毛利率，請檢查數據格式</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                else:
                    # Calculate profit margin from 毛利 and 總計金額 if 毛利率 column is not available
                    try:
                        profit_margin = (total_profit / total_amount * 100) if total_amount > 0 else 0
                        
                        # Format for display
                        formatted_margin = f"{profit_margin:.2f}%" if pd.notna(profit_margin) else "0.00%"
                        
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    f"""
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">計算毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">{formatted_margin}</h2>
                                        <p style="color: #6c757d; font-size: 0.8rem;">注意: 毛利率欄位不存在，使用毛利/總計金額計算</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                    except Exception as e:
                        st.error(f"計算毛利率時發生錯誤: {e}")
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    """
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">計算毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">0.00%</h2>
                                        <p style="color: #dc3545;">無法計算毛利率，請檢查數據格式</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
            except Exception as e:
                st.error(f"計算毛利相關指標時發生錯誤: {e}")
                col1, col2 = st.columns(2)
                with col1:
                    with st.container(border=True):
                        st.markdown(
                            """
                            <div style="text-align: center; padding: 1rem 0;">
                                <h3 style="font-size: 1.2rem; color: #555;">總毛利</h3>
                                <h2 style="font-size: 2rem; font-weight: bold; color: #0d6efd;">$0.00</h2>
                                <p style="color: #dc3545;">無法計算總毛利，請檢查數據格式</p>
                            </div>
                            """,
                            unsafe_allow_html=True
                        )
    else:
        # If 總計金額 is not found, show an error
        st.error("無法計算總銷售金額: 找不到總計金額欄位")
        st.markdown("### 銷售總覽")
        
        with st.container(border=True):
            st.markdown(
                """
                <div style="text-align: center; padding: 2rem 0;">
                    <h2 style="font-size: 1.5rem; color: #555;">總銷售金額</h2>
                    <h1 style="font-size: 3rem; font-weight: bold; color: #0f5132;">$0.00</h1>
                    <p style="color: #dc3545;">無法找到總計金額欄位，請確認數據格式</p>
                </div>
                """,
                unsafe_allow_html=True
            )
        
        # If we have profit data, show that as well (using total_amount as the base)
        if '毛利' in order_df.columns:
            try:
                # Ensure the value is numeric before formatting
                if not pd.api.types.is_numeric_dtype(order_df['毛利']):
                    order_df['毛利'] = pd.to_numeric(order_df['毛利'], errors='coerce')
                
                # Use the sum of the 毛利 column for total gross profit
                total_profit = order_df['毛利'].sum()
                
                # Format for display
                formatted_profit = f"${total_profit:,.2f}" if pd.notna(total_profit) else "$0.00"
                
                # Display the total gross profit
                col1, col2 = st.columns(2)
                
                with col1:
                    with st.container(border=True):
                        st.markdown(
                            f"""
                            <div style="text-align: center; padding: 1rem 0;">
                                <h3 style="font-size: 1.2rem; color: #555;">總毛利</h3>
                                <h2 style="font-size: 2rem; font-weight: bold; color: #0d6efd;">{formatted_profit}</h2>
                            </div>
                            """,
                            unsafe_allow_html=True
                        )
                
                # For profit margin, use the average of the 毛利率 column if available
                if '毛利率' in order_df.columns:
                    try:
                        # Ensure the value is numeric before calculating
                        if not pd.api.types.is_numeric_dtype(order_df['毛利率']):
                            order_df['毛利率'] = pd.to_numeric(order_df['毛利率'], errors='coerce')
                            
                        # Calculate the average profit margin (remove NaN values)
                        avg_profit_margin = order_df['毛利率'].dropna().mean()
                        
                        # Format for display
                        formatted_margin = f"{avg_profit_margin:.2f}%" if pd.notna(avg_profit_margin) else "0.00%"
                        
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    f"""
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">平均毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">{formatted_margin}</h2>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                    except Exception as e:
                        st.error(f"計算平均毛利率時發生錯誤: {e}")
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    """
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">平均毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">0.00%</h2>
                                        <p style="color: #dc3545;">無法計算毛利率，請檢查數據格式</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                else:
                    # Calculate profit margin from 毛利 and 總計金額 if 毛利率 column is not available
                    try:
                        profit_margin = (total_profit / total_amount * 100) if total_amount > 0 else 0
                        
                        # Format for display
                        formatted_margin = f"{profit_margin:.2f}%" if pd.notna(profit_margin) else "0.00%"
                        
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    f"""
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">計算毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">{formatted_margin}</h2>
                                        <p style="color: #6c757d; font-size: 0.8rem;">注意: 毛利率欄位不存在，使用毛利/總計金額計算</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
                    except Exception as e:
                        st.error(f"計算毛利率時發生錯誤: {e}")
                        with col2:
                            with st.container(border=True):
                                st.markdown(
                                    """
                                    <div style="text-align: center; padding: 1rem 0;">
                                        <h3 style="font-size: 1.2rem; color: #555;">計算毛利率</h3>
                                        <h2 style="font-size: 2rem; font-weight: bold; color: #d63384;">0.00%</h2>
                                        <p style="color: #dc3545;">無法計算毛利率，請檢查數據格式</p>
                                    </div>
                                    """,
                                    unsafe_allow_html=True
                                )
            except Exception as e:
                st.error(f"計算毛利相關指標時發生錯誤: {e}")
                col1, col2 = st.columns(2)
                with col1:
                    with st.container(border=True):
                        st.markdown(
                            """
                            <div style="text-align: center; padding: 1rem 0;">
                                <h3 style="font-size: 1.2rem; color: #555;">總毛利</h3>
                                <h2 style="font-size: 2rem; font-weight: bold; color: #0d6efd;">$0.00</h2>
                                <p style="color: #dc3545;">無法計算總毛利，請檢查數據格式</p>
                            </div>
                            """,
                            unsafe_allow_html=True
                        )

# Top Products Section
st.markdown("### 熱門產品銷售")

# Check if we have any sales data processed
if st.session_state.sales_data is not None:
    # Try using the original combined data first
    st.session_state.debug_info.append("嘗試從原始銷售數據生成熱門產品清單")
    top_products = get_top_products(st.session_state.sales_data, n=50)
    
    # If that didn't work, try using the product_level data if available
    if (top_products is None or top_products.empty) and st.session_state.processed_data['product_level'] is not None:
        st.session_state.debug_info.append("從原始數據生成失敗，嘗試使用處理後的產品層級數據")
        top_products = get_top_products(st.session_state.processed_data['product_level'], n=50)
    
    if top_products is not None and not top_products.empty:
        st.success(f"成功找到 {len(top_products)} 項熱門產品")
        
        # Create container with fixed height and scrolling for table
        with st.container(border=True):
            # Display all columns with nicer column headers
            column_rename = {
                "排名": "排名",
                "產品代號": "產品代號",
                "產品名稱": "產品名稱",
                "數量": "銷售數量",
                "小計": "銷售金額(元)"
            }
            display_df = top_products.rename(columns=column_rename)
            
            # Set height of table to show all rows but be scrollable
            st.dataframe(display_df, hide_index=True, height=600, use_container_width=True)
    else:
        st.warning("無法獲取熱門產品清單")
        with st.expander("可能的原因及解決方法"):
            st.markdown("""
            **可能的原因:**
            1. 產品層級的數據缺少必要欄位 (產品代號, 產品名稱, 數量, 小計)
            2. 數據結構與預期不符
            3. 數值欄位的格式不正確
            
            **解決方法:**
            1. 確認上傳的檔案包含所有必要的產品資訊欄位
            2. 查看除錯資訊以取得更詳細的錯誤訊息
            3. 確認產品數據中的數量和金額欄位是數值格式
            """)
else:
    st.info("請先上傳並處理銷售數據，以查看熱門產品清單。")

# Monthly Comparison Section (only show when there are multiple months of data)
if st.session_state.processed_data['monthly_summary'] is not None:
    monthly_summary = st.session_state.processed_data['monthly_summary']
    
    # Check if we have multiple months to compare
    if len(monthly_summary) > 1:
        st.markdown("---")
        st.markdown("### 月度銷售比較")
        
        # Create and display the monthly comparison table
        comparison_table = create_monthly_comparison_table(monthly_summary)
        if comparison_table is not None and not comparison_table.empty:
            st.subheader("月度銷售數據比較")
            with st.container(border=True):
                st.dataframe(comparison_table, hide_index=True, use_container_width=True)
        
        # Daily sales comparison chart
        if st.session_state.processed_data['order_level'] is not None:
            order_df = st.session_state.processed_data['order_level']
            daily_comparison_chart = create_monthly_comparison_chart(order_df)
            
            if daily_comparison_chart is not None:
                st.subheader("每日銷售金額比較")
                with st.container(border=True):
                    st.plotly_chart(daily_comparison_chart, use_container_width=True)

# Version 1.1: Add Daily Sales Chart Section to UI
# --------------------------------------------------
st.markdown("---")
st.markdown("### 日銷售圖表")

# Check if order level data exists
if st.session_state.processed_data['order_level'] is not None:
    order_df_daily = st.session_state.processed_data['order_level'].copy() # Use a copy
    
    # Initial chart generation (uses most recent month by default)
    daily_chart, available_months = create_daily_sales_chart(order_df_daily)
    
    # Check if we got months back (even if chart is initially empty)
    if available_months:
        # Add a month selector using the available months
        selected_month = st.selectbox(
            "選擇月份:",
            options=available_months,
            index=0, # Default to the most recent month
            key="daily_sales_month_selector"
        )
        
        # Regenerate chart with the selected month
        # Pass the selected month to the function
        daily_chart, _ = create_daily_sales_chart(order_df_daily, selected_month) 
        
        # Display the chart if it was generated successfully
        if daily_chart is not None:
            with st.container(border=True):
                st.plotly_chart(daily_chart, use_container_width=True)
                
                # Add some analysis text below the chart
                if selected_month:
                    # --- FIX: Ensure '年月' column exists before filtering ---
                    if '年月' not in order_df_daily.columns:
                        st.session_state.debug_info.append("重新添加 '年月' 欄位以進行分析")
                        if '銷貨日期' in order_df_daily.columns and pd.api.types.is_datetime64_dtype(order_df_daily['銷貨日期']):
                             order_df_daily['年月'] = order_df_daily['銷貨日期'].dt.strftime('%Y-%m')
                        else:
                            st.warning("無法重新生成 '年月' 欄位進行分析，缺少有效的 '銷貨日期'")
                            # Skip analysis if column cannot be created
                            st.stop() 
                    # --- End FIX ---

                    # Filter data again for the selected month for analysis
                    month_data_analysis = order_df_daily[order_df_daily['年月'] == selected_month]
                    
                    if not month_data_analysis.empty:
                        # Group by day for analysis metrics
                        # --- FIX: Ensure '日' column exists before grouping ---
                        if '日' not in month_data_analysis.columns:
                             st.session_state.debug_info.append("重新添加 '日' 欄位以進行分析")
                             if '銷貨日期' in month_data_analysis.columns and pd.api.types.is_datetime64_dtype(month_data_analysis['銷貨日期']):
                                 month_data_analysis['日'] = month_data_analysis['銷貨日期'].dt.day
                             else:
                                 st.warning("無法重新生成 '日' 欄位進行分析，缺少有效的 '銷貨日期'")
                                 st.stop() # Skip analysis
                        # --- End FIX ---
                        daily_sales_analysis = month_data_analysis.groupby(month_data_analysis['銷貨日期'].dt.day)['總計金額'].sum()
                        
                        if not daily_sales_analysis.empty:
                            max_day = daily_sales_analysis.idxmax()
                            max_sales = daily_sales_analysis.max()
                            avg_sales = daily_sales_analysis.mean()
                            total_sales_month = daily_sales_analysis.sum() # Recalculate for consistency
                            
                            # Display metrics in columns
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric(
                                    label="本月總銷售額", 
                                    value=f"${total_sales_month:,.2f}"
                                )
                            with col2:
                                st.metric(
                                    label="最高銷售日", 
                                    value=f"{max_day}日", 
                                    delta=f"${max_sales:,.2f}",
                                    delta_color="normal" # Use normal color for amount
                                )
                            with col3:
                                st.metric(
                                    label="平均日銷售額", 
                                    value=f"${avg_sales:,.2f}"
                                )
                        else:
                            st.info(f"{selected_month} 月份沒有有效的日銷售數據可供分析。")
                    else:
                         st.info(f"{selected_month} 月份沒有數據可供分析。")
        else:
            # Handle case where chart generation failed after selection
             st.warning(f"無法為所選月份 {selected_month} 生成日銷售圖表。")

    else:
        # Handle case where no months were found initially
        st.warning("無法生成日銷售圖表，找不到有效的月份數據。")
else:
    # Message if no order data is loaded yet
    st.info("請先上傳並處理銷售數據，以查看日銷售圖表。")
