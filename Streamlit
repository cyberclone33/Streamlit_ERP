import streamlit as st
import pandas as pd
import numpy as np
import os
import shutil
from io import BytesIO
from datetime import datetime

# Configure page and set up data directories
st.set_page_config(page_title="FAFA ERP 智能銷售助理", layout="wide")

# Initialize session state for section navigation if it doesn't exist
if 'current_section' not in st.session_state:
    st.session_state.current_section = "生成報表"

# Initialize session state for report generation if it doesn't exist
if 'report_generated' not in st.session_state:
    st.session_state.report_generated = False
if 'selected_months_display' not in st.session_state:
    st.session_state.selected_months_display = []
# Initialize dataframes in session state
if 'sales_df' not in st.session_state: st.session_state.sales_df = pd.DataFrame()
if 'summary_df' not in st.session_state: st.session_state.summary_df = pd.DataFrame()
if 'order_summary' not in st.session_state: st.session_state.order_summary = pd.DataFrame()
if 'bc_df' not in st.session_state: st.session_state.bc_df = pd.DataFrame()
if 'merged_df' not in st.session_state: st.session_state.merged_df = pd.DataFrame()
if 'customer_summary' not in st.session_state: st.session_state.customer_summary = pd.DataFrame() # Initialize customer summary
if 'selected_vendor' not in st.session_state: st.session_state.selected_vendor = "請選擇..." # Initialize vendor selection
if 'bc_load_error' not in st.session_state: st.session_state.bc_load_error = None # Initialize error state
if 'merge_possible' not in st.session_state: st.session_state.merge_possible = False # Initialize merge state

# No longer needed sections = ["生成報表", "訂單調閱", "產品分析", "BC 資料比對", "廠商產品查詢"]

# Removed horizontal navigation bar

st.title(f"📊 FAFA - ERP 智能銷售助理 - {st.session_state.current_section}")

# Create data storage directories if they don't exist
DATA_DIR = "uploaded_data"
SALES_DIR = os.path.join(DATA_DIR, "sales_files")
BC_DIR = os.path.join(DATA_DIR, "bc_files")

os.makedirs(SALES_DIR, exist_ok=True)
os.makedirs(BC_DIR, exist_ok=True)

# =================== UTILITY FUNCTIONS ===================

def save_uploaded_file(uploaded_file, directory):
    """Save an uploaded file to the specified directory and return the file path
    If a file with the same name already exists, it will be overwritten"""
    filename = uploaded_file.name
    # Use the original filename without timestamp to avoid duplicates
    file_path = os.path.join(directory, filename)
    
    # Save the file, overwriting if it already exists
    with open(file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    
    return file_path

def get_file_list(directory, file_type=None):
    """Get list of files from the specified directory"""
    if not os.path.exists(directory):
        return []
    
    files = []
    for filename in os.listdir(directory):
        if file_type and not filename.endswith(file_type):
            continue
        file_path = os.path.join(directory, filename)
        if os.path.isfile(file_path):
            # Get file modification time for sorting
            mod_time = os.path.getmtime(file_path)
            # Store filename and path (original name is now the same as filename)
            files.append({
                "name": filename, 
                "path": file_path, 
                "full_name": filename,
                "mod_time": mod_time,
                "mod_time_str": datetime.fromtimestamp(mod_time).strftime("%Y/%m/%d %H:%M")
            })
    
    # Sort by modification time (newest first)
    files.sort(key=lambda x: x["mod_time"], reverse=True)
    return files

def delete_file(file_path):
    """Delete a file from the filesystem"""
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
            return True
        return False
    except Exception as e:
        st.error(f"刪除檔案時發生錯誤: {e}")
        return False

def load_saved_excel_file(file_path):
    """Load a saved Excel file from disk"""
    return pd.read_excel(file_path)

def clean_numeric_columns(df, columns):
    for col in columns:
        if col in df.columns: # Check if column exists before cleaning
            df[col] = df[col].astype(str).str.replace(',', '', regex=False)
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0).round(0).astype(int)
    return df

@st.cache_data # Cache loaded sales data based on file sources, selected months, and mapping
def load_sales_data(_files, selected_months, is_path=False, column_mapping=None):
    # Convert file objects to hashable representation (paths or names) for caching
    # Note: Streamlit's caching might handle UploadedFile objects directly, but being explicit is safer.
    # We use _files as the argument name to avoid modifying the original list inside the cached function.
    files = []
    if not is_path:
        # Use file names and sizes as a proxy for identity if they are UploadedFile objects
        files = [(f.name, f.size) for f in _files]
    else:
        # Use file paths if they are strings
        files = tuple(_files) # Convert list to tuple to make it hashable

    df_list = []
    
    for file_source in files:
        # Handle both file objects and file paths
        if is_path:
            file_name = os.path.basename(file_source)
            file_path = file_source
        else: # UploadedFile object
            file_name = file_source.name
            file_path = file_source # Pass the object itself to pd.read_excel
            
        # Check if the filename contains any of the selected months
        file_matches_month = False
        for month in selected_months:
            if month in file_name:
                file_matches_month = True
                break
        
        if file_matches_month:
            try:
                # pd.read_excel can handle both paths and file-like objects
                df = pd.read_excel(file_path)
                
                # Apply column mapping if provided
                if column_mapping and isinstance(column_mapping, dict):
                    df = df.rename(columns=column_mapping)
                
                # Process the hierarchical structure before adding to list
                order_columns = ['銷貨單號', '訂單單號', '銷貨日期', '客戶代號', '客戶名稱', 
                                '部門代號', '部門名稱', '發票號碼', '未稅小計', '營業稅', 
                                '折讓金額', '稅前折價', '總計金額', '實收總額', '成本總額', '毛利', '毛利率']
                
                # Add missing order columns with None
                for col in order_columns:
                    if col not in df.columns:
                        df[col] = None
                
                # Forward fill the order information
                df[order_columns] = df[order_columns].fillna(method='ffill')
                
                # Add order identification column
                if '銷貨單號' in df.columns:
                    df['order_id'] = df['銷貨單號'].astype(str)
                
                df_list.append(df)
            except Exception as e:
                st.error(f"無法讀取檔案 {file_name}: {e}")
                
    if df_list:
        combined = pd.concat(df_list, ignore_index=True)
        
        # Process numeric columns (ensure they exist first)
        numeric_cols = ['數量', '小計', '精準成本', '精準毛利']
        combined = clean_numeric_columns(combined, numeric_cols)
        
        # Also ensure numeric processing for order-level columns
        order_numeric_cols = ['未稅小計', '營業稅', '折讓金額', '稅前折價', 
                             '總計金額', '實收總額', '成本總額', '毛利']
        combined = clean_numeric_columns(combined, order_numeric_cols)
        
        return combined
    return pd.DataFrame()

@st.cache_data # Cache monthly summary generation
def generate_monthly_summary(_df):
    # Use _df to avoid modifying the original df inside the cached function
    df = _df.copy()
    if df.empty or '產品代號' not in df.columns:
        return pd.DataFrame()
        
    agg_dict = {
        '數量': 'sum',
        '小計': 'sum',
        '精準成本': 'sum',
        '精準毛利': 'sum',
        '產品名稱': 'first',
        '倉別代號': 'first',
        '倉別名稱': 'first'
    }
    # Only include columns that actually exist in the dataframe
    valid_agg_dict = {k: v for k, v in agg_dict.items() if k in df.columns}

    if not valid_agg_dict: # Need at least one column to aggregate
        return pd.DataFrame()

    grouped = df.groupby('產品代號').agg(valid_agg_dict).reset_index()
    
    # Ensure essential columns exist after aggregation, fill with 0 if not
    for col in ['數量', '小計', '精準成本', '精準毛利']:
        if col not in grouped.columns:
            grouped[col] = 0

    return grouped.sort_values(by='小計', ascending=False)

@st.cache_data # Cache order summary generation
def generate_order_summary(_df):
    """Generate a summary table at the order level"""
    # Use _df to avoid modifying the original df inside the cached function
    df = _df.copy()
    if df.empty:
        return pd.DataFrame()
        
    required_cols = ['銷貨單號'] # Minimal requirement
    if not all(col in df.columns for col in required_cols):
        return pd.DataFrame()
    
    # Get unique order rows based on the first occurrence of each order number
    order_df = df.drop_duplicates(subset=['銷貨單號']).copy()
    
    # Define potential order-level columns
    order_cols = ['銷貨單號', '訂單單號', '銷貨日期', '客戶代號', '客戶名稱', 
                '部門代號', '部門名稱', '發票號碼', '未稅小計', '營業稅', 
                '折讓金額', '稅前折價', '總計金額', '實收總額', '成本總額', '毛利', '毛利率']
    
    # Filter to only include columns that actually exist in the order_df
    existing_cols = [col for col in order_cols if col in order_df.columns]
    
    if not existing_cols:
        return pd.DataFrame()
    
    # Start with just the existing order-level columns
    order_summary = order_df[existing_cols].copy()
    
    # Add product count for each order
    if '銷貨單號' in df.columns:
        product_counts = df.groupby('銷貨單號').size().reset_index(name='產品數量')
        order_summary = pd.merge(order_summary, product_counts, on='銷貨單號', how='left')
    
    # Calculate order total from product subtotals ONLY if an order total column doesn't exist
    order_total_cols = ['總計金額', '實收總額', '未稅小計']
    existing_total_col = next((col for col in order_total_cols if col in order_summary.columns), None)

    if not existing_total_col and '小計' in df.columns and '銷貨單號' in df.columns:
        product_totals = df.groupby('銷貨單號')['小計'].sum().reset_index(name='訂單產品總額')
        order_summary = pd.merge(order_summary, product_totals, on='銷貨單號', how='left')
    
    # Sort by date (newest first) and then by order number if date exists
    if '銷貨日期' in order_summary.columns:
        order_summary = order_summary.sort_values(by=['銷貨日期', '銷貨單號'], ascending=[False, True])
    
    return order_summary

@st.cache_data # Cache customer summary generation
def generate_customer_summary(_order_summary_df):
    """Generate a summary of top customers from the order summary"""
    # Use _order_summary_df to avoid modifying the original df inside the cached function
    order_summary_df = _order_summary_df.copy()
    if order_summary_df.empty:
        return pd.DataFrame()
        
    # Determine which amount column to use from the order summary
    amount_col = None
    for col in ['總計金額', '實收總額', '未稅小計', '訂單產品總額']: # Check order summary columns
        if col in order_summary_df.columns:
            amount_col = col
            break
    
    if '客戶名稱' not in order_summary_df.columns or amount_col is None:
        return pd.DataFrame()
    
    # Group by customer name and sum the total amount and count unique orders
    customer_summary = order_summary_df.groupby('客戶名稱').agg(
        消費總額=(amount_col, 'sum'),
        訂單數量=('銷貨單號', 'nunique') # Count unique order numbers
    ).reset_index()
    
    # Calculate average order value, handle division by zero
    customer_summary['平均單筆金額'] = customer_summary.apply(
        lambda row: row['消費總額'] / row['訂單數量'] if row['訂單數量'] > 0 else 0,
        axis=1
    )
    
    # Sort by total amount spent, descending
    customer_summary = customer_summary.sort_values(by='消費總額', ascending=False)
    
    return customer_summary

@st.cache_data # Cache dead stock identification
def identify_dead_stock(_summary_df, _bc_df):
    """Identifies products with inventory but no sales in the selected period."""
    summary_df = _summary_df.copy()
    bc_df = _bc_df.copy()

    if bc_df.empty or '產品代號' not in bc_df.columns or '數量' not in bc_df.columns:
        st.warning("BC data is missing required columns ('產品代號', '數量') for dead stock analysis.")
        return pd.DataFrame()
    if summary_df.empty or '產品代號' not in summary_df.columns:
         # If summary is empty, all BC stock is potentially "dead" for the period, but let's be cautious
         st.info("Sales summary is empty. Dead stock analysis might show all inventoried items.")
         # Create a dummy summary to allow the merge logic to proceed, marking all as having 0 sales
         summary_df = pd.DataFrame({'產品代號': [], '銷售數量': []}) # Use '銷售數量' as the merge function expects
    elif '數量' in summary_df.columns:
         # Rename sales quantity if it exists in the summary
         summary_df.rename(columns={'數量': '銷售數量'}, inplace=True)
    else:
         # If '數量' column doesn't exist in summary, add it as 0
         summary_df['銷售數量'] = 0


    # Prepare BC data: select relevant columns and standardize product code
    bc_subset = bc_df[['產品代號', '數量']].copy()
    bc_subset.rename(columns={'數量': '庫存數量'}, inplace=True)
    bc_subset['產品代號'] = bc_subset['產品代號'].astype(str).str.strip()
    bc_subset['庫存數量'] = pd.to_numeric(bc_subset['庫存數量'], errors='coerce').fillna(0).astype(int)

    # Prepare Sales data: select relevant columns and standardize product code
    sales_subset = summary_df[['產品代號', '銷售數量']].copy()
    sales_subset['產品代號'] = sales_subset['產品代號'].astype(str).str.strip()
    sales_subset['銷售數量'] = pd.to_numeric(sales_subset['銷售數量'], errors='coerce').fillna(0).astype(int)


    # Merge BC data with sales data (right merge to keep all BC items)
    merged_for_dead_stock = pd.merge(sales_subset, bc_subset, on='產品代號', how='right')

    # Identify dead stock: Inventory > 0 and Sales == 0 (or NaN if no match in sales)
    dead_stock_df = merged_for_dead_stock[
        (merged_for_dead_stock['庫存數量'] > 0) &
        (merged_for_dead_stock['銷售數量'].fillna(0) == 0)
    ].copy()

    # Add product names from original BC data if available
    if '產品名稱' in bc_df.columns:
        bc_names = bc_df[['產品代號', '產品名稱']].copy()
        bc_names['產品代號'] = bc_names['產品代號'].astype(str).str.strip()
        dead_stock_df = pd.merge(dead_stock_df, bc_names.drop_duplicates(subset=['產品代號']), on='產品代號', how='left')

    # Select and order final columns
    final_cols_order = ['產品代號', '產品名稱', '庫存數量']
    final_cols = [col for col in final_cols_order if col in dead_stock_df.columns]
    dead_stock_df = dead_stock_df[final_cols]

    return dead_stock_df.sort_values(by='庫存數量', ascending=False)

@st.cache_data
def perform_abc_analysis(_summary_df):
    """Performs ABC analysis based on product sales value ('小計')."""
    summary_df = _summary_df.copy()
    if summary_df.empty or '小計' not in summary_df.columns or '產品代號' not in summary_df.columns:
        st.warning("Cannot perform ABC analysis: Summary data is empty or missing '小計' or '產品代號'.")
        return pd.DataFrame()

    # Ensure '小計' is numeric
    summary_df['小計'] = pd.to_numeric(summary_df['小計'], errors='coerce').fillna(0)

    # Sort by sales value descending
    df_sorted = summary_df.sort_values(by='小計', ascending=False)

    # Calculate cumulative sales and percentage
    df_sorted['累計銷售額'] = df_sorted['小計'].cumsum()
    total_sales = df_sorted['小計'].sum()

    if total_sales == 0:
        st.info("Total sales are zero, cannot calculate ABC percentages.")
        df_sorted['累計銷售佔比'] = 0.0
        df_sorted['ABC分類'] = 'C' # Assign all to C if no sales
    else:
        df_sorted['累計銷售佔比'] = (df_sorted['累計銷售額'] / total_sales) * 100

        # Assign ABC category
        def assign_abc(percentage):
            if percentage <= 70: # A items: top 70%
                return 'A'
            elif percentage <= 90: # B items: next 20% (70% to 90%)
                return 'B'
            else: # C items: remaining 10%
                return 'C'
        df_sorted['ABC分類'] = df_sorted['累計銷售佔比'].apply(assign_abc)

    # Select and reorder columns for clarity
    abc_cols = ['產品代號', '產品名稱', '小計', '累計銷售額', '累計銷售佔比', 'ABC分類']
    # Add other relevant columns if they exist
    optional_cols = ['數量', '精準毛利', '庫存數量', '廠商簡稱'] # Add more if needed
    final_cols = abc_cols + [col for col in optional_cols if col in df_sorted.columns]
    # Ensure all selected columns actually exist before returning
    final_cols = [col for col in final_cols if col in df_sorted.columns]


    return df_sorted[final_cols]


# Function to merge sales data with BC data
def merge_with_bc(sales_summary_df, bc_df):
    """
    Merges the sales summary DataFrame with the BC (inventory) DataFrame based on '產品代號'.

    Args:
        sales_summary_df (pd.DataFrame): DataFrame containing summarized sales data with '產品代號'.
        bc_df (pd.DataFrame): DataFrame containing BC inventory data with '產品代號', '數量' (inventory), and '廠商簡稱'.

    Returns:
        pd.DataFrame: Merged DataFrame with sales data and corresponding BC inventory and vendor info.
                      Returns an empty DataFrame if inputs are invalid or missing required columns.
    """
    # Input validation
    if sales_summary_df.empty or '產品代號' not in sales_summary_df.columns:
        st.warning("Sales summary data is empty or missing '產品代號'. Cannot merge.")
        return pd.DataFrame()
    if bc_df.empty or '產品代號' not in bc_df.columns:
        st.warning("BC data is empty or missing '產品代號'. Cannot merge.")
        # Return the sales summary without BC info if BC data is invalid
        # Add a placeholder column to indicate missing BC data
        sales_summary_df_copy = sales_summary_df.copy()
        sales_summary_df_copy['庫存數量'] = 'N/A'
        sales_summary_df_copy['廠商簡稱'] = 'N/A'
        return sales_summary_df_copy

    # --- Data Preparation ---
    # Create copies to avoid modifying original dataframes
    sales_summary_copy = sales_summary_df.copy()
    bc_df_copy = bc_df.copy()

    # Standardize '產品代號' (Product Code) to string and strip whitespace for reliable merging
    sales_summary_copy['產品代號'] = sales_summary_copy['產品代號'].astype(str).str.strip()
    bc_df_copy['產品代號'] = bc_df_copy['產品代號'].astype(str).str.strip()

    # Rename sales quantity column for clarity *before* merge
    if '數量' in sales_summary_copy.columns:
        sales_summary_copy.rename(columns={'數量': '銷售數量'}, inplace=True)

    # Select and rename relevant columns from BC data
    bc_cols_to_merge = ['產品代號']
    bc_rename_map = {}
    if '數量' in bc_df_copy.columns:
        bc_cols_to_merge.append('數量')
        bc_rename_map['數量'] = '庫存數量' # Rename BC quantity to avoid conflict
    if '廠商簡稱' in bc_df_copy.columns:
        bc_cols_to_merge.append('廠商簡稱')
        # No rename needed for '廠商簡稱' unless it conflicts

    # Check if essential BC columns exist before subsetting
    missing_bc_cols = [col for col in ['數量', '廠商簡稱'] if col not in bc_df_copy.columns]
    if missing_bc_cols:
        st.warning(f"BC data is missing columns: {', '.join(missing_bc_cols)}. Merge will proceed without them.")

    # Create a subset of BC data with only the necessary columns (handle missing ones)
    valid_bc_cols_to_merge = [col for col in bc_cols_to_merge if col in bc_df_copy.columns]
    if '產品代號' not in valid_bc_cols_to_merge: # Should not happen due to initial check, but safety first
         st.error("Critical error: '產品代號' somehow lost in BC data processing.")
         return sales_summary_copy # Return sales data only

    bc_subset = bc_df_copy[valid_bc_cols_to_merge].copy()

    # Apply renaming to the subset
    bc_subset.rename(columns=bc_rename_map, inplace=True)

    # --- Merge Operation ---
    # Perform left merge: keep all sales summary rows, add BC info where available
    merged_df = pd.merge(sales_summary_copy, bc_subset, on='產品代號', how='left')

    # --- Post-Merge Handling ---
    # Fill NaN values resulting from the merge (products sold but not in BC file or missing BC columns)
    if '庫存數量' in merged_df.columns:
        # Convert to numeric first, coercing errors, then fillna, then int
        merged_df['庫存數量'] = pd.to_numeric(merged_df['庫存數量'], errors='coerce').fillna(0).astype(int)
    else:
        # If '庫存數量' wasn't even in bc_subset, add it as 0
        merged_df['庫存數量'] = 0
        st.info("Note: '庫存數量' column was not found in BC data; added as 0.") # Re-applying indentation fix


    if '廠商簡稱' in merged_df.columns:
        merged_df['廠商簡稱'] = merged_df['廠商簡稱'].fillna('未知廠商') # Placeholder for missing vendor info
    else:
        # If '廠商簡稱' wasn't in bc_subset, add it
        merged_df['廠商簡稱'] = '未知廠商'
        st.info("Note: '廠商簡稱' column was not found in BC data; added as '未知廠商'.")

    # Ensure '銷售數量' exists, filling with 0 if it wasn't in the original sales summary
    if '銷售數量' not in merged_df.columns:
        merged_df['銷售數量'] = 0

    # --- Final Column Order (Optional but good practice) ---
    # Define desired column order, including the potentially renamed/added columns
    desired_cols_order = [
        '產品代號', '產品名稱', # From sales summary
        '銷售數量', '小計', '精準成本', '精準毛利', # From sales summary (renamed quantity)
        '庫存數量', '廠商簡稱', # From BC data
        # Add other columns from sales_summary_df if they exist and are desired
        '倉別代號', '倉別名稱'
    ]
    # Filter to only include columns that actually exist in the merged_df
    final_columns = [col for col in desired_cols_order if col in merged_df.columns]
    # Add any remaining columns from merged_df not in the desired list
    final_columns.extend([col for col in merged_df.columns if col not in final_columns])

    return merged_df[final_columns] # Return with potentially reordered columns

def vendor_summary_table(merged_df):
    if merged_df.empty or '廠商簡稱' not in merged_df.columns or '小計' not in merged_df.columns:
        return pd.DataFrame()
        
    summary = merged_df.groupby('廠商簡稱').agg(
        廠商總小計=('小計', 'sum')
    ).reset_index().sort_values(by='廠商總小計', ascending=False)
    return summary

def extract_months_from_filenames(files):
    months = []
    for f in files:
        name = f.name
        try:
            import re
            date_patterns = [r'(\d{6})', r'(\d{4}[-_][01]\d)', r'(\d{4}年[01]?\d月)']
            found_date = False
            for pattern in date_patterns:
                matches = re.findall(pattern, name)
                if matches:
                    for match in matches:
                        clean_match = re.sub(r'[-_年月]', '', match)
                        if clean_match.startswith('20') and len(clean_match) >= 6:
                            year_month = clean_match[:6]
                            if year_month not in months: # Avoid duplicates
                                months.append(year_month)
                            found_date = True
                            break # Found a match for this file with this pattern
                if found_date: break # Found a match for this file
            if not found_date:
                digits = ''.join(c for c in name if c.isdigit())
                if len(digits) >= 6 and digits.startswith('20'):
                    year_month = digits[:6]
                    if year_month not in months:
                         months.append(year_month)
        except:
            continue
    return sorted(list(set(months)), reverse=True)

def check_required_columns(df, required_columns):
    """Check if all required columns exist and suggest mappings."""
    present_columns = []
    missing_columns = []
    suggestions = {}
    df_columns_lower = {col.lower(): col for col in df.columns} # Store original casing
    required_columns_lower = {col.lower() for col in required_columns}

    for req_col_orig in required_columns:
        req_col_lower = req_col_orig.lower()
        if req_col_lower in df_columns_lower:
            present_columns.append(df_columns_lower[req_col_lower]) # Use original casing
        else:
            missing_columns.append(req_col_orig)
            # Suggest similar column names (case-insensitive comparison)
            potential_matches = []
            for df_col_lower, df_col_orig in df_columns_lower.items():
                 # Simple substring check or more advanced fuzzy matching could be used
                 if req_col_lower in df_col_lower or df_col_lower in req_col_lower:
                     potential_matches.append(df_col_orig) # Suggest original casing
            if potential_matches:
                suggestions[req_col_orig] = potential_matches
                
    # Return original casing for present columns as well
    present_columns_original_case = [col for col in required_columns if col.lower() in df_columns_lower]

    return present_columns_original_case, missing_columns, suggestions

# =================== MAIN PAGE ===================

# Define required headers for later use
required_headers = [
    "銷貨單號", "訂單單號", "銷貨日期", "客戶代號", "客戶名稱", "部門代號", "部門名稱",
    "發票號碼", "未稅小計", "營業稅", "折讓金額", "稅前折價", "總計金額", "實收總額",
    "成本總額", "毛利", "毛利率", "產品代號", "產品名稱", "倉別代號", "倉別名稱",
    "數量", "單位", "單價", "小計", "成本總值", "產品毛利", "產品毛利率",
    "銷售單價1", "精準成本", "精準毛利", "單位管銷成本", "管銷成本合計"
]

# Group headers by category for better organization
header_categories = {
    "訂單基本資訊": ["銷貨單號", "訂單單號", "銷貨日期"],
    "客戶資訊": ["客戶代號", "客戶名稱", "部門代號", "部門名稱", "發票號碼"],
    "訂單金額資訊": ["未稅小計", "營業稅", "折讓金額", "稅前折價", "總計金額", "實收總額", "成本總額", "毛利", "毛利率"],
    "產品資訊": ["產品代號", "產品名稱", "倉別代號", "倉別名稱"],
    "產品銷售細節": ["數量", "單位", "單價", "小計", "成本總值", "產品毛利", "產品毛利率", "銷售單價1", "精準成本", "精準毛利"],
    "其他": ["單位管銷成本", "管銷成本合計"]
}

# Create sample data for reference and download
sample_data = {
    "銷貨單號": ["S202407001", "S202407001", "S202407002", "S202407002"], "訂單單號": ["O202407001", "O202407001", "O202407002", "O202407002"],
    "銷貨日期": ["2024/07/01", "2024/07/01", "2024/07/05", "2024/07/05"], "客戶代號": ["C001", "C001", "C002", "C002"],
    "客戶名稱": ["寵物樂園", "寵物樂園", "毛孩之家", "毛孩之家"], "部門代號": ["D01", "D01", "D01", "D01"],
    "部門名稱": ["銷售部", "銷售部", "銷售部", "銷售部"], "發票號碼": ["IV240701", "IV240701", "IV240705", "IV240705"],
    "未稅小計": [3000, 3000, 2500, 2500], "營業稅": [150, 150, 125, 125], "總計金額": [3150, 3150, 2625, 2625],
    "產品代號": ["P001", "P002", "P001", "P003"], "產品名稱": ["狗糧1kg", "貓糧1kg", "狗糧1kg", "貓玩具"],
    "倉別代號": ["W01", "W01", "W01", "W02"], "倉別名稱": ["主倉", "主倉", "主倉", "配件倉"],
    "數量": [10, 5, 8, 3], "單位": ["包", "包", "包", "個"], "單價": [200, 250, 200, 300],
    "小計": [2000, 1250, 1600, 900], "精準成本": [1400, 900, 1120, 500], "精準毛利": [600, 350, 480, 400]
}
sample_df = pd.DataFrame(sample_data)

# Divider
st.markdown("---")

# Add sidebar information
st.sidebar.title("資料來源選擇")
with st.sidebar.expander("❓ 檔案格式說明"):
    st.write("""
    ### 銷貨檔案要求
    - 檔案類型: Excel (.xlsx)
    - 銷貨檔案應包含客戶資訊、產品資訊、銷售數量及金額等欄位
    - 檔案名稱建議包含年月，例如: `sales_202407.xlsx`
    ### BC 檔案要求
    - 檔案類型: Excel (.xlsx)
    - 應包含產品代號、庫存數量等欄位
    ### 常見問題
    1. **缺少欄位**: 如果提示缺少欄位，請檢查您的檔案是否包含所有必要欄位
    2. **欄位名稱不匹配**: 請確保欄位名稱與系統需求一致
    3. **檔案未顯示**: 請確保檔案名稱中包含年月標記
    """)

data_source = st.sidebar.radio("選擇數據來源方式", ["上傳新檔案", "使用已上傳的檔案"])

if data_source == "上傳新檔案":
    with st.sidebar.expander("📊 數據格式範例"):
        st.code("""
銷貨單號    銷貨日期    客戶代號    客戶名稱    產品代號    產品名稱    數量    單價    小計
S202301001  2023/01/05  C001       寵物樂園    P001       狗糧1kg    10     200     2000
S202301001  2023/01/05  C001       寵物樂園    P002       貓糧1kg    5      250     1250
S202301002  2023/01/10  C002       毛孩之家    P003       寵物玩具    8      150     1200
        """)

# Initialize file sources
sales_files = None
bc_file = None
sales_data_source = []
bc_data_source = None

# File Upload / Selection UI
if data_source == "上傳新檔案":
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("上傳銷貨檔案")
        sales_files = st.file_uploader("上傳銷貨單毛利分析 Excel（可多選）", type=['xlsx'], accept_multiple_files=True, key="sales_uploader")
        if sales_files:
            temp_saved_sales = []
            for file in sales_files:
                file_path = save_uploaded_file(file, SALES_DIR)
                temp_saved_sales.append({"name": file.name, "path": file_path})
            # Only update session state if new files are uploaded
            if temp_saved_sales:
                 st.session_state.saved_sales_files = temp_saved_sales
            sales_data_source = sales_files # Use the uploader objects directly for loading
    with col2:
        st.subheader("上傳 BC 資料")
        bc_file = st.file_uploader("上傳 BC SKU 資料 Excel（單一）", type=['xlsx'], key="bc_uploader")
        if bc_file:
            file_path = save_uploaded_file(bc_file, BC_DIR)
            st.session_state.saved_bc_file = {"name": bc_file.name, "path": file_path}
            bc_data_source = st.session_state.saved_bc_file['path'] # Use path for loading
else: # Use previously uploaded files
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("選擇已上傳的銷貨檔案")
        available_sales_files = get_file_list(SALES_DIR, ".xlsx")
        if not available_sales_files:
            st.info("尚未上傳任何銷貨檔案")
        else:
            file_options = [f"{file['name']}" for file in available_sales_files]
            selected_sales_files_names = st.multiselect("選擇銷貨檔案", file_options, key="sales_selector")
            # Map selected file names to their paths for loading
            sales_data_source = [f['path'] for f in available_sales_files if f['name'] in selected_sales_files_names]
    with col2:
        st.subheader("選擇已上傳的 BC 檔案")
        available_bc_files = get_file_list(BC_DIR, ".xlsx")
        if not available_bc_files:
            st.info("尚未上傳任何 BC 檔案")
        else:
            file_options = [f"{file['name']}" for file in available_bc_files]
            selected_bc_file_name = st.selectbox("選擇 BC 檔案", file_options, key="bc_selector")
            # Map selected file name to its path for loading
            bc_data_source = next((f['path'] for f in available_bc_files if f['name'] == selected_bc_file_name), None)

# Month selection based on available files
months = []
files_for_month_extraction = []
if data_source == "上傳新檔案" and sales_files:
    files_for_month_extraction = sales_files
elif data_source == "使用已上傳的檔案" and sales_data_source:
    # Create mock file objects with names for extraction function
    files_for_month_extraction = [type('obj', (object,), {'name': os.path.basename(path)}) for path in sales_data_source]

if files_for_month_extraction:
    months = extract_months_from_filenames(files_for_month_extraction)

selected_months = []
if months:
    selected_months = st.multiselect("選擇月份（可複選）", months, key="month_selector")

# Initialize session state for column mapping if it doesn't exist
if 'column_mapping' not in st.session_state:
    st.session_state.column_mapping = {}

# Show preview of uploaded/selected files
st.markdown("---")
st.subheader("📋 上傳/選擇檔案預覽")

preview_file_source = None
if data_source == "上傳新檔案" and sales_files:
    preview_file_source = sales_files[0] # Preview first uploaded file
elif data_source == "使用已上傳的檔案" and sales_data_source:
    preview_file_source = sales_data_source[0] # Preview first selected file path

if preview_file_source:
    try:
        sample_df_preview = pd.read_excel(preview_file_source, nrows=5)
        st.write("銷貨資料預覽 (前5筆):")
        st.dataframe(sample_df_preview, use_container_width=True)
        
        present_headers, missing_headers, suggestions = check_required_columns(sample_df_preview, required_headers)
        
        if missing_headers:
            st.warning(f"**注意:** 上傳/選擇的檔案缺少 {len(missing_headers)} 個必要欄位")
            with st.expander("🔄 欄位對應設定 (處理欄位名稱不一致)", expanded=True):
                st.write("您可以將檔案中的欄位對應到系統需要的欄位名稱:")
                with st.form("column_mapping_form"):
                    essential_cols = ['產品代號', '產品名稱', '數量', '單價', '小計', '精準成本', '精準毛利'] # Added cost/profit
                    missing_essential = [col for col in essential_cols if col in missing_headers]
                    mapping_dict = {}
                    file_columns = list(sample_df_preview.columns)
                    
                    if missing_essential:
                        st.write("**必要欄位對應:**")
                        for col in missing_essential:
                            suggested_options = suggestions.get(col, [])
                            options = [""] + suggested_options + [c for c in file_columns if c not in suggested_options]
                            # Use current mapping as default if available
                            current_mapping = next((k for k, v in st.session_state.column_mapping.items() if v == col), None)
                            default_index = options.index(current_mapping) if current_mapping in options else 0
                            mapping_dict[col] = st.selectbox(f"請選擇對應 '{col}' 的欄位:", options, index=default_index)
                    
                    other_missing = [col for col in missing_headers if col not in missing_essential]
                    if other_missing and len(other_missing) <= 10: # Show more optional mappings
                        st.write("**其他欄位對應 (選填):**")
                        for col in other_missing:
                            suggested_options = suggestions.get(col, [])
                            options = [""] + suggested_options + [c for c in file_columns if c not in suggested_options]
                            current_mapping = next((k for k, v in st.session_state.column_mapping.items() if v == col), None)
                            default_index = options.index(current_mapping) if current_mapping in options else 0
                            mapping_dict[col] = st.selectbox(f"請選擇對應 '{col}' 的欄位:", options, index=default_index)
                    
                    submitted = st.form_submit_button("應用欄位對應")
                    if submitted:
                        final_mapping = {v: k for k, v in mapping_dict.items() if v} # Reversed: {file_col: required_col}
                        st.session_state.column_mapping = final_mapping
                        st.success(f"✅ 已設定 {len(final_mapping)} 個欄位對應")
                        st.rerun() # Rerun to apply mapping immediately

                if st.session_state.column_mapping:
                    st.write("**目前的欄位對應:**")
                    mapping_items = [{"原始欄位": orig, "對應至": mapped} for orig, mapped in st.session_state.column_mapping.items()]
                    st.dataframe(pd.DataFrame(mapping_items), use_container_width=True)
                    if st.button("清除所有對應"):
                        st.session_state.column_mapping = {}
                        st.rerun()
            
            missing_data = [{"缺少欄位": col, "建議對應": ", ".join(suggestions.get(col, ["無"])[:3])} for col in missing_headers]
            missing_df = pd.DataFrame(missing_data)
            st.dataframe(missing_df, use_container_width=True)
            st.info("💡 提示: 若檔案中使用了不同的欄位名稱，請使用上方的欄位對應功能來解決")
        else:
            st.success("✅ 所有必要欄位都已存在")
        st.write(f"檔案統計: {len(sample_df_preview.columns)} 個欄位")
    except Exception as e:
        st.error(f"無法讀取檔案預覽: {e}")
else:
    st.info("請上傳或選擇檔案以查看預覽")

st.markdown("---")

# =================== SECTION DISPLAY LOGIC ===================

# Removed logic for sections: "廠商產品查詢", "產品分析", "BC 資料比對", "訂單調閱"
    
if st.session_state.current_section == "生成報表":
    # Button to trigger report generation
    has_data_input = (data_source == "上傳新檔案" and sales_files) or \
                     (data_source == "使用已上傳的檔案" and sales_data_source)
                     
    if st.button("▶️ 生成報表", key="generate_report_button") and has_data_input and selected_months:
        with st.spinner("處理資料中..."):
            try:
                # --- Reset previous report state ---
                st.session_state.report_generated = False
                keys_to_clear = ['sales_df', 'summary_df', 'order_summary', 'bc_df', 'merged_df', 'selected_months_display', 'customer_summary']
                for key in keys_to_clear:
                    if key in st.session_state: del st.session_state[key]
                # --- End Reset ---

                column_mapping = st.session_state.get('column_mapping', {})
                
                # Determine if loading from path or object
                load_is_path = (data_source == "使用已上傳的檔案")
                
                # Load sales data
                sales_df_loaded = load_sales_data(sales_data_source, selected_months, is_path=load_is_path, column_mapping=column_mapping)

                if sales_df_loaded.empty:
                    st.error("沒有找到符合選擇月份的資料，請檢查您的選擇。")
                    st.session_state.report_generated = False
                else:
                    st.session_state.sales_df = sales_df_loaded
                    st.session_state.summary_df = generate_monthly_summary(sales_df_loaded)
                    st.session_state.order_summary = generate_order_summary(sales_df_loaded)
                    # Generate customer summary from order summary
                    st.session_state.customer_summary = generate_customer_summary(st.session_state.order_summary)
                    
                    # Perform ABC Analysis
                    st.session_state.abc_analysis_df = perform_abc_analysis(st.session_state.summary_df)
                    
                    # Initialize dead stock dataframe
                    st.session_state.dead_stock_df = pd.DataFrame() 

                    # --- Process BC data ---
                    bc_df_loaded = pd.DataFrame()
                    merged_df_loaded = pd.DataFrame()
                    bc_load_error = None
                    merge_possible = False

                    # Determine BC source path
                    current_bc_source = None
                    if data_source == "上傳新檔案" and bc_file:
                        if 'saved_bc_file' in st.session_state and st.session_state.saved_bc_file:
                            current_bc_source = st.session_state.saved_bc_file['path']
                    elif data_source == "使用已上傳的檔案" and bc_data_source:
                        current_bc_source = bc_data_source

                    # Attempt to load BC data if source exists
                    if current_bc_source:
                        if os.path.exists(str(current_bc_source)):
                            try:
                                bc_df_loaded = pd.read_excel(current_bc_source)
                                if bc_df_loaded.empty:
                                    bc_load_error = "BC 檔案已載入但內容為空。"
                                elif '產品代號' not in bc_df_loaded.columns:
                                    bc_load_error = "BC 檔案缺少 '產品代號' 欄位。"
                            except Exception as e:
                                bc_load_error = f"讀取 BC 檔案時發生錯誤: {e}"
                        else:
                            bc_load_error = "選擇的 BC 檔案路徑不存在。"
                    # No warning if BC file wasn't provided intentionally
                    # elif (data_source == "上傳新檔案" and bc_file) or (data_source == "使用已上傳的檔案" and bc_data_source):
                    #      bc_load_error = "選擇的 BC 檔案無法找到或讀取。"

                    # --- Standardize Product Codes before checking validity ---
                    summary_df_to_merge = st.session_state.summary_df.copy() # Work on a copy
                    if not summary_df_to_merge.empty and '產品代號' in summary_df_to_merge.columns:
                        summary_df_to_merge['產品代號'] = summary_df_to_merge['產品代號'].astype(str).str.strip()
                    if not bc_df_loaded.empty and '產品代號' in bc_df_loaded.columns:
                        # Ensure bc_df_loaded is updated after loading inside the try block
                        pass # Standardization will happen after loading now

                    # Check if merge is possible (re-check validity after standardization)
                    summary_df_valid = not summary_df_to_merge.empty and '產品代號' in summary_df_to_merge.columns
                    # bc_df_valid check needs to happen after loading
                    
                    # Attempt to load BC data if source exists
                    if current_bc_source:
                        if os.path.exists(str(current_bc_source)):
                            try:
                                bc_df_loaded = pd.read_excel(current_bc_source)
                                if bc_df_loaded.empty:
                                    bc_load_error = "BC 檔案已載入但內容為空。"
                                elif '產品代號' not in bc_df_loaded.columns:
                                    bc_load_error = "BC 檔案缺少 '產品代號' 欄位。"
                                else:
                                    # Standardize BC product code here
                                    bc_df_loaded['產品代號'] = bc_df_loaded['產品代號'].astype(str).str.strip()
                            except Exception as e:
                                bc_load_error = f"讀取 BC 檔案時發生錯誤: {e}"
                        else:
                            bc_load_error = "選擇的 BC 檔案路徑不存在。"

                    # Now check BC validity again after potential loading and standardization
                    bc_df_valid = not bc_df_loaded.empty and '產品代號' in bc_df_loaded.columns

                    if summary_df_valid and bc_df_valid:
                        merge_possible = True
                        try:
                            # Pass the potentially standardized dataframes to the merge function
                            merged_df_loaded = merge_with_bc(summary_df_to_merge, bc_df_loaded)
                        except Exception as e:
                             st.error(f"合併銷售與 BC 資料時發生錯誤: {e}")
                             merged_df_loaded = pd.DataFrame() # Ensure it's empty on merge error
                    elif bc_load_error:
                         st.warning(f"無法進行 BC 資料合併，因為：{bc_load_error}")
                    elif not summary_df_valid:
                         st.warning("無法進行 BC 資料合併，因為銷售彙總資料無效或缺少 '產品代號'。")
                    # If BC wasn't provided, no warning needed here, merge_possible remains False

                    # --- Identify Dead Stock (after BC and Summary are processed) ---
                    if bc_df_valid and summary_df_valid: # Only run if both inputs are valid
                        try:
                            st.session_state.dead_stock_df = identify_dead_stock(st.session_state.summary_df, bc_df_loaded)
                        except Exception as e:
                            st.error(f"計算滯銷庫存時發生錯誤: {e}")
                            st.session_state.dead_stock_df = pd.DataFrame() # Ensure it's empty on error
                    elif bc_df_valid: # BC is valid, but sales summary might be empty/invalid
                         # Attempt identification, function handles empty summary
                         try:
                             st.session_state.dead_stock_df = identify_dead_stock(st.session_state.summary_df, bc_df_loaded)
                         except Exception as e:
                             st.error(f"計算滯銷庫存時發生錯誤 (無銷售資料): {e}")
                             st.session_state.dead_stock_df = pd.DataFrame()
                    # --- End Dead Stock Identification ---

                    # Store results in session state
                    st.session_state.bc_df = bc_df_loaded
                    st.session_state.merged_df = merged_df_loaded
                    st.session_state.report_generated = True
                    st.session_state.bc_load_error = bc_load_error # Store potential load error
                    st.session_state.merge_possible = merge_possible # Store if merge was attempted
                    st.session_state.selected_months_display = selected_months
                    st.rerun() # Rerun immediately to display the report section

            except Exception as e:
                st.error(f"生成報表時發生未預期的錯誤: {e}")
                st.session_state.report_generated = False

    # --- Report Display Section ---
    if st.session_state.get('report_generated', False):
        # Retrieve data from session state
        sales_df = st.session_state.get('sales_df', pd.DataFrame())
        summary_df = st.session_state.get('summary_df', pd.DataFrame())
        order_summary = st.session_state.get('order_summary', pd.DataFrame())
        bc_df = st.session_state.get('bc_df', pd.DataFrame())
        merged_df = st.session_state.get('merged_df', pd.DataFrame())
        customer_summary = st.session_state.get('customer_summary', pd.DataFrame())
        selected_months_display = st.session_state.get('selected_months_display', [])

        if not sales_df.empty:
            order_tab, product_tab, bc_tab = st.tabs(["訂單摘要", "產品分析", "BC 資料比對"])

            with product_tab:
                st.subheader(f"🧾 {'、'.join(selected_months_display)} 產品銷售彙總表")
                # Add ABC Analysis tab
                product_tab1, product_tab2, product_tab3, product_tab4 = st.tabs(["前20大產品", "產品分析圖表", "完整產品列表", "ABC 分析"])
                show_debug = st.checkbox("顯示計算驗證資訊", value=False, key="debug_checkbox_product", help="開啟此選項可以檢視數據計算過程和驗證資訊")
                
                with product_tab1:
                    st.markdown("### 🏆 前20大銷售產品")
                    if not summary_df.empty:
                        top_products = summary_df.sort_values(by='小計', ascending=False).head(20).copy()
                        display_df = top_products.copy()
                        for col in ['小計', '精準成本', '精準毛利']:
                            if col in display_df.columns:
                                display_df[col] = display_df[col].apply(lambda x: f"${x:,.0f}")
                        display_df.insert(0, '排名', range(1, len(display_df) + 1))
                        display_cols = ['排名', '產品代號', '產品名稱', '數量', '小計', '精準成本', '精準毛利']
                        st.dataframe(display_df[[col for col in display_cols if col in display_df.columns]], use_container_width=True)
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            st.markdown("#### 前20大產品銷售額")
                            import altair as alt
                            chart_data = pd.DataFrame({'產品': top_products['產品名稱'] + ' (' + top_products['產品代號'] + ')', '銷售額': top_products['小計']})
                            chart = alt.Chart(chart_data).mark_bar().encode(y=alt.Y('產品:N', sort='-x', title=None), x=alt.X('銷售額:Q', title='銷售額'), color=alt.value('#4CAF50'), tooltip=['產品', '銷售額']).properties(height=400)
                            text = chart.mark_text(align='left', baseline='middle', dx=5, color='black').encode(text=alt.Text('銷售額', format='$,.0f'))
                            final_chart = (chart + text).configure_view(strokeWidth=0).configure_axis(labelFontSize=12, titleFontSize=14, grid=False)
                            st.altair_chart(final_chart, use_container_width=True)
                        with col2:
                            st.markdown("#### 前20大產品銷售佔比")
                            total_sales_all = summary_df['小計'].sum()
                            if total_sales_all > 0:
                                top_products['佔比'] = top_products['小計'] / total_sales_all * 100
                                top_products['標籤'] = top_products.apply(lambda x: f"{x['產品名稱']} ({x['佔比']:.1f}%)", axis=1)
                                if show_debug:
                                    st.write(f"總銷售額: ${total_sales_all:,.0f}")
                                    st.write(f"前20大產品銷售額: ${top_products['小計'].sum():,.0f} ({top_products['小計'].sum()/total_sales_all*100:.1f}%)")
                                import plotly.express as px
                                fig = px.pie(top_products, values='小計', names='標籤', title='前20大產品銷售佔比', color_discrete_sequence=px.colors.qualitative.Pastel)
                                fig.update_traces(textposition='inside', textinfo='percent+label', hoverinfo='label+percent+value', textfont_size=10, marker=dict(line=dict(color='#FFFFFF', width=1)))
                                fig.update_layout(showlegend=False, margin=dict(t=50, b=20, l=0, r=0))
                                st.plotly_chart(fig, use_container_width=True)
                                st.info("💡 圓餅圖顯示前20大產品的銷售額佔比。")
                            else: st.info("總銷售額為零，無法計算佔比。")
                    else: st.warning("無產品彙總資料可顯示。")

                with product_tab2:
                    st.markdown("### 📊 產品分析圖表")
                    if not summary_df.empty:
                        viz_type = st.selectbox("選擇圖表類型", ["產品銷量與銷售額比較", "產品毛利分析", "產品類別分析", "產品成本結構"], key="viz_type_selector")
                        # ... [Visualization code using summary_df, ensure keys are used for widgets] ...
                        # Example for Profit Analysis Scatter Plot
                        if viz_type == "產品毛利分析":
                             if '精準毛利' in summary_df.columns and '小計' in summary_df.columns:
                                 profit_data = summary_df.copy()
                                 profit_data['毛利率'] = profit_data.apply(lambda x: (x['精準毛利'] / x['小計'] * 100) if x['小計'] > 0 else 0, axis=1)
                                 profit_data['精準毛利_abs'] = profit_data['精準毛利'].abs()
                                 import plotly.express as px
                                 fig = px.scatter(profit_data, x='小計', y='毛利率', size='精準毛利_abs', color='精準毛利', hover_name='產品名稱', text='產品代號', title='產品銷售額 vs 毛利率分析', labels={'小計': '銷售額', '毛利率': '毛利率 (%)', '精準毛利': '毛利額'}, color_continuous_scale=px.colors.sequential.Viridis)
                                 fig.update_traces(textposition='top center', marker=dict(sizemin=5), selector=dict(mode='markers+text'))
                                 fig.update_layout(xaxis=dict(title='銷售額', tickprefix='$'), yaxis=dict(title='毛利率 (%)'))
                                 st.plotly_chart(fig, use_container_width=True)
                                 # ... [rest of profit analysis code] ...
                             else: st.warning("缺少 '精準毛利' 或 '小計' 欄位，無法進行毛利分析。")
                        # ... [Implement other viz_type options similarly] ...
                    else: st.warning("無產品彙總資料可供分析。")
                    
                with product_tab3:
                    st.markdown("### 📋 完整產品列表")
                    st.dataframe(summary_df, use_container_width=True)
                    if not summary_df.empty:
                        csv_summary = summary_df.to_csv(index=False).encode('utf-8-sig')
                        st.download_button("💾 下載產品彙總 CSV", csv_summary, f"product_summary_{'_'.join(selected_months_display)}.csv", "text/csv", key="download_summary")
                
                with product_tab4:
                    st.markdown("### 📈 ABC 分析 (依銷售額)")
                    st.markdown("""
                    **分類標準:**
                    - **A類:** 累計銷售額佔比前 70% 的產品
                    - **B類:** 累計銷售額佔比 70% - 90% 的產品
                    - **C類:** 累計銷售額佔比後 10% 的產品
                    """)
                    abc_df = st.session_state.get('abc_analysis_df', pd.DataFrame())
                    if not abc_df.empty:
                        # Display summary counts
                        abc_counts = abc_df['ABC分類'].value_counts().sort_index()
                        st.metric("A類產品數量", abc_counts.get('A', 0))
                        st.metric("B類產品數量", abc_counts.get('B', 0))
                        st.metric("C類產品數量", abc_counts.get('C', 0))

                        # Format percentage column
                        display_abc_df = abc_df.copy()
                        if '累計銷售佔比' in display_abc_df.columns:
                             display_abc_df['累計銷售佔比'] = display_abc_df['累計銷售佔比'].map('{:.2f}%'.format)
                        if '小計' in display_abc_df.columns:
                             display_abc_df['小計'] = display_abc_df['小計'].apply(lambda x: f"${x:,.0f}")
                        if '累計銷售額' in display_abc_df.columns:
                             display_abc_df['累計銷售額'] = display_abc_df['累計銷售額'].apply(lambda x: f"${x:,.0f}")


                        st.dataframe(display_abc_df, use_container_width=True)
                        csv_abc = abc_df.to_csv(index=False).encode('utf-8-sig')
                        st.download_button(
                            "💾 下載 ABC 分析 CSV",
                            csv_abc,
                            f"abc_analysis_{'_'.join(selected_months_display)}.csv",
                            "text/csv",
                            key="download_abc"
                        )
                    else:
                        st.warning("無法顯示 ABC 分析，請確認已生成報表且銷售資料包含 '小計' 欄位。")


            with order_tab:
                st.subheader(f"📋 {'、'.join(selected_months_display)} 訂單摘要表")
                
                # Add tabs within Order Summary
                order_tab1, order_tab2, order_tab3, order_tab4 = st.tabs(["銷售表現摘要", "前10大客戶", "訂單詳細資料", "銷售趨勢"])

                with order_tab1: # Sales Performance Summary
                    if order_summary.empty:
                        st.warning("無法生成訂單摘要，可能缺少必要的訂單資料欄位。")
                    else:
                        total_column = next((col for col in ['總計金額', '實收總額', '未稅小計', '訂單產品總額'] if col in order_summary.columns), None)
                        st.markdown("### 📊 銷售表現摘要")
                        total_orders = len(order_summary)
                        total_amount = order_summary[total_column].sum() if total_column else 0
                        avg_order = total_amount / total_orders if total_orders > 0 else 0
                        
                        # Create a stylish metrics section with custom styling
                        metrics_container = st.container()
                        with metrics_container:
                            # Use CSS to style the metrics cards
                            st.markdown("""
                            <style>
                            .metric-card {
                                background-color: #f8f9fa;
                                border-radius: 10px;
                                padding: 20px;
                                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                                text-align: center;
                                transition: transform 0.3s;
                            }
                            .metric-card:hover {
                                transform: translateY(-5px);
                            }
                            .metric-value {
                                font-size: 28px;
                                font-weight: bold;
                                color: #1E88E5;
                                margin: 10px 0;
                            }
                            .metric-title {
                                font-size: 16px;
                                color: #455A64;
                                margin-top: 5px;
                            }
                            </style>
                            """, unsafe_allow_html=True)

                            # Create three metric cards in columns
                            col1, col2, col3 = st.columns(3)

                            with col1:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">訂單總數</div>
                                    <div class="metric-value">{total_orders:,}</div>
                                    <div class="metric-title">筆</div>
                                </div>
                                """, unsafe_allow_html=True)

                            with col2:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">總銷售額</div>
                                    <div class="metric-value">${total_amount:,.0f}</div>
                                    <div class="metric-title">新台幣</div>
                                </div>
                                """, unsafe_allow_html=True)

                            with col3:
                                st.markdown(f"""
                                <div class="metric-card">
                                    <div class="metric-title">平均訂單金額</div>
                                    <div class="metric-value">${avg_order:,.0f}</div>
                                    <div class="metric-title">新台幣/筆</div>
                                </div>
                                """, unsafe_allow_html=True)

                        # Add spacing
                        st.markdown("<br>", unsafe_allow_html=True)

                with order_tab2: # Top 10 Customers
                    if order_summary.empty:
                         st.warning("無法生成客戶摘要，可能缺少必要的訂單資料欄位。")
                    elif customer_summary.empty:
                         st.warning("無法生成客戶摘要。")
                    else:
                        st.markdown("### 🏆 前10大客戶")
                        top_customers = customer_summary.head(10)
                        # Create two columns for visualization and table
                        viz_col, table_col = st.columns([3, 2])

                        with viz_col:
                            # Create a bar chart for top customers
                            data = {
                                'customer': top_customers['客戶名稱'].tolist(),
                                'amount': top_customers['消費總額'].tolist(),
                                'orders': top_customers['訂單數量'].tolist()
                            }

                            # Use Streamlit native charts instead of matplotlib to avoid font issues
                            import altair as alt

                            # Prepare the data in the format Altair expects
                            chart_data = pd.DataFrame({
                                '客戶名稱': data['customer'],
                                '消費總額': data['amount'],
                                '訂單數量': data['orders']
                            })

                            # Create label with formatted amount and order count
                            chart_data['label'] = chart_data.apply(
                                lambda x: f"${x['消費總額']:,.0f} ({x['訂單數量']}筆)",
                                axis=1
                            )

                            # Create an Altair chart
                            chart = alt.Chart(chart_data).mark_bar().encode(
                                y=alt.Y('客戶名稱:N', sort='-x', title=None),
                                x=alt.X('消費總額:Q', title='銷售總額'),
                                color=alt.value('#2196F3'),
                                tooltip=['客戶名稱', '消費總額', '訂單數量', 'label']
                            ).properties(
                                title='前10大客戶銷售額',
                                height=400
                            )

                            # Add text labels
                            text = chart.mark_text(
                                align='left',
                                baseline='middle',
                                dx=5,  # Offset the text slightly to the right of the bar
                                color='black'
                            ).encode(
                                text='label'
                            )

                            # Combine chart and text
                            final_chart = (chart + text).configure_view(
                                strokeWidth=0
                            ).configure_title(
                                fontSize=16,
                                font='Arial',
                                anchor='start',
                                fontWeight='bold'
                            ).configure_axis(
                                labelFontSize=12,
                                titleFontSize=14,
                                grid=False
                            )

                            # Display the chart
                            st.altair_chart(final_chart, use_container_width=True)

                        with table_col:
                            # Format the table for display
                            display_df = top_customers.copy()
                            display_df['消費總額'] = display_df['消費總額'].apply(lambda x: f"${x:,.0f}")
                            display_df['平均單筆金額'] = display_df['平均單筆金額'].apply(lambda x: f"${x:,.0f}")

                            # Display the table
                            st.dataframe(display_df, use_container_width=True)

                        # Add spacing
                        st.markdown("<br>", unsafe_allow_html=True)

                with order_tab3: # Order Details
                    if order_summary.empty:
                         st.warning("無法顯示訂單詳細資料，可能缺少必要的訂單資料欄位。")
                    else:
                        st.markdown("### 📝 訂單詳細資料")
                        st.dataframe(order_summary, use_container_width=True)
                        csv_orders = order_summary.to_csv(index=False).encode('utf-8-sig')
                        st.download_button("💾 下載訂單摘要 CSV", csv_orders, f"order_summary_{'_'.join(selected_months_display)}.csv", "text/csv", key="download_orders")

                with order_tab4: # Sales Trend
                    st.markdown("### 📈 銷售趨勢 (依月份)")
                    if order_summary.empty or '銷貨日期' not in order_summary.columns:
                        st.warning("無法生成銷售趨勢圖，缺少 '銷貨日期' 欄位。")
                    else:
                        # Ensure '銷貨日期' is datetime
                        order_summary['銷貨日期'] = pd.to_datetime(order_summary['銷貨日期'], errors='coerce')
                        # Drop rows where date conversion failed
                        order_summary_trend = order_summary.dropna(subset=['銷貨日期']).copy()

                        if not order_summary_trend.empty:
                            # Determine the amount column to use
                            amount_col_trend = next((col for col in ['總計金額', '實收總額', '未稅小計', '訂單產品總額'] if col in order_summary_trend.columns), None)

                            if amount_col_trend:
                                # Set date as index and resample by month
                                order_summary_trend.set_index('銷貨日期', inplace=True)
                                monthly_sales = order_summary_trend.resample('ME')[amount_col_trend].sum().reset_index() # 'ME' for Month End
                                monthly_sales['銷貨月份'] = monthly_sales['銷貨日期'].dt.strftime('%Y-%m') # Format for display

                                if not monthly_sales.empty:
                                    import altair as alt
                                    chart = alt.Chart(monthly_sales).mark_line(point=True).encode(
                                        x=alt.X('銷貨月份:T', title='月份'),
                                        y=alt.Y(f'{amount_col_trend}:Q', title='月銷售額'),
                                        tooltip=['銷貨月份:T', alt.Tooltip(f'{amount_col_trend}:Q', format='$,.0f', title='銷售額')]
                                    ).properties(
                                        title='月銷售額趨勢'
                                    )
                                    st.altair_chart(chart, use_container_width=True)
                                else:
                                    st.info("選定期間內無足夠資料繪製趨勢圖。")
                            else:
                                st.warning("訂單摘要中找不到可用的金額欄位 ('總計金額', '實收總額', '未稅小計', '訂單產品總額') 來繪製趨勢圖。")
                        else:
                             st.warning("無法轉換 '銷貨日期' 為有效日期格式，無法繪製趨勢圖。")

            with bc_tab:
                st.subheader("🔄 BC 資料比對")
                bc_load_error_display = st.session_state.get('bc_load_error', None)
                merge_possible_display = st.session_state.get('merge_possible', False)

                if bc_load_error_display:
                    st.warning(f"BC 資料處理問題: {bc_load_error_display}")
                    st.info("無法顯示 BC 相關報表。")
                elif bc_df.empty and not merge_possible_display:
                     # This case means BC file was likely not provided or selected
                     st.info("未提供 BC 資料，無法進行比對分析。")
                elif not merge_possible_display and not bc_df.empty:
                     # BC data loaded, but summary was invalid
                     st.warning("銷售彙總資料無效，無法進行 BC 比對。")
                elif merge_possible_display and merged_df.empty:
                    # Merge was possible and attempted, but result is empty (no matches)
                    st.warning("銷售資料中的產品代號與 BC 資料中無匹配項目。請檢查兩份檔案中的產品代號是否一致（包括格式與空格）。") # Refined message
                    # Optionally display the raw BC data here if needed
                    # st.subheader("已載入的 BC 資料 (無匹配銷售項目)")
                    # st.dataframe(bc_df, use_container_width=True)
                elif not merged_df.empty: # Corrected indentation for this block
                        # Merge successful and has data
                        # Add Dead Stock tab
                        bc_tab1, bc_tab2, bc_tab3, bc_tab4, bc_tab5 = st.tabs(["交叉比對結果", "廠商銷售彙總", "熱銷品精準毛利高到低", "廠商產品查詢", "滯銷庫存"])
                        with bc_tab1:
                            st.subheader("與 BC 資料交叉比對結果") # This header might be redundant now
                            st.dataframe(merged_df, use_container_width=True)
                            csv_merged = merged_df.to_csv(index=False).encode('utf-8-sig')
                            st.download_button("下載交叉比對 CSV", csv_merged, f"merged_bc_sales_{'_'.join(selected_months_display)}.csv", "text/csv", key="download_merged")
                        with bc_tab2:
                            st.subheader("廠商銷售彙總")
                            vendor_df = vendor_summary_table(merged_df)
                            st.dataframe(vendor_df, use_container_width=True)
                            csv_vendor = vendor_df.to_csv(index=False).encode('utf-8-sig')
                            st.download_button("下載廠商彙總 CSV", csv_vendor, f"vendor_summary_{'_'.join(selected_months_display)}.csv", "text/csv", key="download_vendor")
                        with bc_tab3:
                            st.subheader("熱銷品精準毛利高到低")
                            if not summary_df.empty and '精準毛利' in summary_df.columns:
                                 profit_sorted_df = summary_df.sort_values(by='精準毛利', ascending=False).copy()
                                 if not bc_df.empty and '數量' in bc_df.columns and '產品代號' in bc_df.columns:
                                     inventory_dict = dict(zip(bc_df['產品代號'], bc_df['數量']))
                                     profit_sorted_df['庫存'] = profit_sorted_df['產品代號'].map(inventory_dict)
                                     profit_sorted_df['庫存'] = profit_sorted_df['庫存'].astype(str).str.replace(',', '', regex=False)
                                     profit_sorted_df['庫存'] = pd.to_numeric(profit_sorted_df['庫存'], errors='coerce').fillna(0).astype(int)
                                     if '數量' in profit_sorted_df.columns: # Check if sales quantity exists
                                         profit_sorted_df['銷售/天'] = profit_sorted_df['數量'] / 30
                                         profit_sorted_df['庫存天數'] = profit_sorted_df.apply(lambda x: round(x['庫存'] / x['銷售/天']) if x['銷售/天'] > 0 else 0, axis=1)
                                         def inventory_status(days):
                                             if days <= 0: return "缺貨"
                                             elif days < 30: return "低"
                                             elif days < 90: return "適中"
                                             else: return "過多"
                                         profit_sorted_df['庫存狀態'] = profit_sorted_df['庫存天數'].apply(inventory_status)
                                     else: profit_sorted_df['庫存狀態'] = "未知 (無銷售數量)"
                                 else: profit_sorted_df['庫存狀態'] = "未知 (無BC庫存)"
                                 # ... [Display table and download button for profit_sorted_df] ...
                                 st.dataframe(profit_sorted_df, use_container_width=True) # Simplified display for brevity
                                 csv_profit_sorted = profit_sorted_df.to_csv(index=False).encode('utf-8-sig')
                                 st.download_button("下載精準毛利排序 CSV", csv_profit_sorted, f"profit_sorted_products_{'_'.join(selected_months_display)}.csv", "text/csv", key="download_profit_sorted")
                            else: st.warning("缺少資料無法生成此報表。")
                        with bc_tab4:
                            st.subheader("廠商產品查詢 (於本次報表範圍內)")
                            # Check if BC data and vendor column are available
                            if not bc_df.empty and '廠商簡稱' in bc_df.columns:
                                # Check if merged data is available for vendor filtering
                                if not merged_df.empty and '廠商簡稱' in merged_df.columns:
                                    # Get unique vendors from the *merged* data relevant to the report
                                    report_vendors = sorted(merged_df['廠商簡稱'].dropna().unique().tolist())
                                    # Optionally remove the placeholder vendor
                                    if '未知廠商' in report_vendors:
                                        report_vendors.remove('未知廠商')

                                    # Proceed if there are actual vendors in the report data
                                    if report_vendors:
                                        selected_vendor_report = st.selectbox(
                                            "選擇廠商查看其本次銷售產品:",
                                            ["請選擇..."] + report_vendors,
                                            key="vendor_selector_report_tab" # Ensure unique key
                                        )
                                        # Display details if a vendor is selected
                                        if selected_vendor_report != "請選擇...":
                                            # Filter merged data for the selected vendor
                                            vendor_merged_products = merged_df[merged_df['廠商簡稱'] == selected_vendor_report].copy()
                                            st.write(f"**{selected_vendor_report}** 在本次報表範圍內銷售了 **{len(vendor_merged_products)}** 項產品:")

                                            # Define and display relevant columns from the merged data
                                            display_cols_vendor = ['產品代號', '產品名稱', '銷售數量', '小計', '精準毛利', '庫存數量']
                                            # Ensure columns exist before trying to display them
                                            final_display_cols = [col for col in display_cols_vendor if col in vendor_merged_products.columns]
                                            st.dataframe(
                                                vendor_merged_products[final_display_cols].sort_values(by='小計', ascending=False),
                                                use_container_width=True
                                            )

                                            # Add an option to view all products from this vendor (using original BC data)
                                            if st.checkbox(f"顯示 {selected_vendor_report} 的所有 BC 產品資料", key="show_all_vendor_bc_report"):
                                                # Filter original BC data for the selected vendor
                                                vendor_all_bc_products = bc_df[bc_df['廠商簡稱'] == selected_vendor_report].copy()
                                                st.write(f"**{selected_vendor_report}** 在 BC 資料中共有 **{len(vendor_all_bc_products)}** 項產品:")
                                                # Define and display basic columns from BC data
                                                basic_columns_all = ['產品代號', '產品名稱', '單位', '數量'] # Note: '數量' here is BC inventory
                                                display_columns_all = [col for col in basic_columns_all if col in vendor_all_bc_products.columns]
                                                st.dataframe(
                                                    vendor_all_bc_products[display_columns_all].sort_values('產品代號'),
                                                    use_container_width=True
                                                )
                                                # Provide download for all BC products of the vendor
                                                csv_vendor_all_bc = vendor_all_bc_products.to_csv(index=False).encode('utf-8-sig')
                                                st.download_button(
                                                    label=f"下載 {selected_vendor_report} 所有 BC 產品資料", # Corrected parameter name
                                                    data=csv_vendor_all_bc, # Corrected parameter name
                                                    file_name=f"{selected_vendor_report}_all_bc_products.csv", # Corrected parameter name
                                                    mime="text/csv", # Corrected parameter name
                                                    key="download_vendor_all_bc_report" # Ensure unique key
                                                )
                                    # Handle case where no vendors were found in the merged data
                                    else:
                                        st.info("本次報表範圍內沒有特定廠商的銷售資料可供查詢。")
                                # Handle case where merged data is missing vendor info
                                else:
                                    st.warning("合併後的資料缺少廠商資訊，無法進行查詢。")
                            # Handle case where BC data is missing vendor info or not loaded
                            else:
                                st.warning("BC檔案中缺少'廠商簡稱'欄位或未載入BC資料，無法進行廠商產品查詢。")
                        with bc_tab5:
                             st.subheader("📦 滯銷庫存 (有庫存但期間無銷售)")
                             dead_stock_df = st.session_state.get('dead_stock_df', pd.DataFrame())
                             if not dead_stock_df.empty:
                                 st.write(f"找到 {len(dead_stock_df)} 項滯銷產品 (庫存 > 0 且本期銷售 = 0)")
                                 st.dataframe(dead_stock_df, use_container_width=True)
                                 csv_dead_stock = dead_stock_df.to_csv(index=False).encode('utf-8-sig')
                                 st.download_button(
                                     "💾 下載滯銷庫存 CSV",
                                     csv_dead_stock,
                                     f"dead_stock_{'_'.join(selected_months_display)}.csv",
                                     "text/csv",
                                     key="download_dead_stock"
                                 )
                             elif bc_df.empty or '數量' not in bc_df.columns:
                                 st.info("無法計算滯銷庫存，因為 BC 資料未載入或缺少 '數量' 欄位。")
                             else:
                                 st.success("✅ 在此期間內，所有有庫存的產品都有銷售紀錄。")

        else:
            # This warning is for the main report generation failure
            st.warning("報表生成失敗或未選擇有效月份的資料。")

    # Display message if no report is generated yet and not in another section
    elif st.session_state.current_section == "生成報表":
         st.info("請先選擇數據來源，選擇月份後按下『生成報表』")

# --- File Management and Field Overview Sections ---
st.markdown("---")
st.subheader("系統設定與管理")
file_mgmt_col, fields_overview_col = st.columns(2)

with file_mgmt_col:
    st.markdown("### 📁 檔案管理")
    if 'file_to_delete' not in st.session_state: st.session_state.file_to_delete = None
    if 'delete_type' not in st.session_state: st.session_state.delete_type = None
    file_mgmt_tab1, file_mgmt_tab2 = st.tabs(["銷貨檔案", "BC 檔案"])
    with file_mgmt_tab1:
        sales_files_list = get_file_list(SALES_DIR, ".xlsx")
        if st.button("🔄 重新整理銷貨檔案列表", key="refresh_sales"): st.rerun()
        if not sales_files_list: st.info("尚未上傳任何銷貨檔案")
        else:
            st.write(f"已上傳的銷貨檔案 ({len(sales_files_list)})")
            for i, file in enumerate(sales_files_list):
                cols = st.columns([6, 3, 1])
                cols[0].text(f"{i+1}. {file['name']}")
                cols[1].text(f"修改: {file['mod_time_str']}")
                if cols[2].button("🗑️", key=f"delete_sales_{i}", help="刪除此檔案"):
                    st.session_state.file_to_delete = file['path']
                    st.session_state.delete_type = "sales"
                    st.rerun()
            if st.button("🗑️ 刪除所有銷貨檔案", type="secondary", key="delete_all_sales"):
                st.session_state.file_to_delete = "ALL_SALES"
                st.session_state.delete_type = "all_sales"
                st.rerun()
    with file_mgmt_tab2:
        bc_files_list = get_file_list(BC_DIR, ".xlsx")
        if st.button("🔄 重新整理BC檔案列表", key="refresh_bc"): st.rerun()
        if not bc_files_list: st.info("尚未上傳任何 BC 檔案")
        else:
            st.write(f"已上傳的 BC 檔案 ({len(bc_files_list)})")
            for i, file in enumerate(bc_files_list):
                cols = st.columns([6, 3, 1])
                cols[0].text(f"{i+1}. {file['name']}")
                cols[1].text(f"修改: {file['mod_time_str']}")
                if cols[2].button("🗑️", key=f"delete_bc_{i}", help="刪除此檔案"):
                    st.session_state.file_to_delete = file['path']
                    st.session_state.delete_type = "bc"
                    st.rerun()
            if st.button("🗑️ 刪除所有BC檔案", type="secondary", key="delete_all_bc"):
                st.session_state.file_to_delete = "ALL_BC"
                st.session_state.delete_type = "all_bc"
                st.rerun()

with fields_overview_col:
    with st.expander("📝 必要欄位一覽", expanded=False):
        st.markdown("上傳檔案需包含下列欄位，否則可能導致分析失敗：")
        header_tabs = st.tabs(list(header_categories.keys()))
        for i, (category, headers) in enumerate(header_categories.items()):
            with header_tabs[i]:
                category_headers = [h for h in headers if h in required_headers]
                if category_headers:
                    headers_df = pd.DataFrame({"欄位名稱": category_headers})
                    st.dataframe(headers_df, use_container_width=True)
                else: st.info(f"此類別中沒有必要的欄位")
        st.markdown("### 範例檔案")
        col1, col2 = st.columns(2)
        with col1:
            csv_sample = sample_df.to_csv(index=False).encode('utf-8-sig')
            st.download_button("⬇️ 下載範例檔案CSV", csv_sample, "sales_sample.csv", "text/csv", key="download_csv_sample")
        with col2:
            excel_sample = BytesIO()
            sample_df.to_excel(excel_sample, index=False, engine='openpyxl')
            excel_sample.seek(0)
            st.download_button("⬇️ 下載範例檔案Excel", excel_sample, "sales_sample.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", key="download_excel_sample")
        st.info("""💡 **提示:** 關鍵欄位如「產品代號」、「數量」、「小計」等必須有值。""")

# Handle file deletion confirmation
if st.session_state.file_to_delete:
    with st.form(key="delete_confirmation_form"): # Added form key
        file_name_display = os.path.basename(st.session_state.file_to_delete) if st.session_state.delete_type in ["sales", "bc"] else "所有檔案"
        delete_msg = f"確定要刪除檔案 '{file_name_display}' 嗎？此操作無法恢復。"
        if st.session_state.delete_type == "all_sales": delete_msg = f"確定要刪除所有 {len(get_file_list(SALES_DIR, '.xlsx'))} 個銷貨檔案嗎？此操作無法恢復。"
        if st.session_state.delete_type == "all_bc": delete_msg = f"確定要刪除所有 {len(get_file_list(BC_DIR, '.xlsx'))} 個BC檔案嗎？此操作無法恢復。"
        st.warning(delete_msg)
        
        col1, col2 = st.columns([1, 1])
        with col1: confirm_delete = st.form_submit_button("⚠️ 確認刪除")
        with col2: cancel_delete = st.form_submit_button("取消")
        
        if confirm_delete:
            deleted_count = 0
            if st.session_state.delete_type in ["sales", "bc"]:
                if delete_file(st.session_state.file_to_delete): deleted_count = 1
            elif st.session_state.delete_type == "all_sales":
                for file in get_file_list(SALES_DIR, ".xlsx"):
                    if delete_file(file['path']): deleted_count += 1
            elif st.session_state.delete_type == "all_bc":
                 for file in get_file_list(BC_DIR, ".xlsx"):
                    if delete_file(file['path']): deleted_count += 1
            
            st.success(f"已成功刪除 {deleted_count} 個檔案")
            st.session_state.file_to_delete = None
            st.session_state.delete_type = None
            st.rerun()
        
        if cancel_delete:
            st.session_state.file_to_delete = None
            st.session_state.delete_type = None
            st.rerun()
